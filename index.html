<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>EzID Taiwan v1.7.6 - å°ˆæ¥­ç©©å®šç‰ˆ</title>
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0/dist/body-pix.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
<style>
    body { background-color: #f1f5f9; color: #1e293b; font-family: system-ui, sans-serif; -webkit-tap-highlight-color: transparent; }
    .canvas-container { position: relative; touch-action: none; background: #e2e8f0; border-radius: 24px; overflow: hidden; border: 4px solid #fff; box-shadow: 0 10px 30px -5px rgba(0,0,0,0.1); }
    canvas { width: 100%; height: auto; display: block; background: white; }
    .id-guide { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -55%); width: 62%; height: 62%; border: 2px dashed rgba(239, 68, 68, 0.4); border-radius: 50%; pointer-events: none; z-index: 10; }
    input[type=range] { -webkit-appearance: none; width: 100%; height: 8px; background: #cbd5e1; border-radius: 4px; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%; background: #0f172a; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    .bg-dot { width: 34px; height: 34px; border-radius: 50%; cursor: pointer; border: 3px solid white; box-shadow: 0 0 0 1px #cbd5e1; transition: 0.2s; }
    .bg-dot.active { transform: scale(1.1); box-shadow: 0 0 0 3px #3b82f6; }
    .no-scrollbar::-webkit-scrollbar { display: none; }
</style>
</head>
<body class="p-3 md:p-8">
<div id="root"></div>

<script type="text/babel">
const { useState, useRef, useEffect, useCallback } = React;

const EzIDApp = () => {
    const [image, setImage] = useState(null);
    const [isCam, setIsCam] = useState(false);
    const [mode, setMode] = useState('MIXED');
    const [bgColor, setBgColor] = useState('#007bff'); // é è¨­çµ¦å°ˆæ¥­è—
    const [p, setP] = useState({ x: 0, y: 0, s: 0.7 });
    const [suit, setSuit] = useState({ id: null, x: 175, y: 340, s: 0.35 });
    const [isProcessing, setIsProcessing] = useState(false);
    const [msg, setMsg] = useState('');
    
    const canvasRef = useRef(null);
    const videoRef = useRef(null);
    const suitImg = useRef(new Image());
    const isDragging = useRef(false);
    const lastPos = useRef({ x: 0, y: 0 });
    const lastDist = useRef(0);

    const getClothesPath = (id) => id ? `${window.location.href.split('?')[0].replace(/\/[^\/]*$/, '')}/clothes/suit-${id}.png` : "";

    // å®‰å…¨è½‰æ›ï¼šç¢ºä¿ Image å°è±¡ä¸å¸¶å®‰å…¨éš±æ‚£
    const makeSafeImage = (imgSource) => {
        return new Promise((resolve) => {
            const canvas = document.createElement('canvas');
            canvas.width = imgSource.width || imgSource.videoWidth;
            canvas.height = imgSource.height || imgSource.videoHeight;
            const ctx = canvas.getContext('2d');
            if (imgSource.videoWidth) { // è™•ç†ç›¸æ©Ÿé¡åƒ
                ctx.translate(canvas.width, 0); ctx.scale(-1, 1);
            }
            ctx.drawImage(imgSource, 0, 0);
            const safeImg = new Image();
            safeImg.onload = () => resolve(safeImg);
            safeImg.src = canvas.toDataURL('image/png');
        });
    };

    const runAutoAlign = async () => {
        if (!image || !window.faceModel) return;
        setMsg('AI è‡‰éƒ¨åµæ¸¬ä¸­...');
        setIsProcessing(true);
        try {
            const preds = await window.faceModel.estimateFaces(image, false);
            if (preds.length > 0) {
                const face = preds[0];
                const [x1, y1] = face.topLeft, [x2, y2] = face.bottomRight;
                const faceCX = (x1 + x2) / 2, faceCY = (y1 + y2) / 2, faceH = (y2 - y1);
                const scale = (350 * 0.45) / faceH;
                setP({ s: scale, x: (image.width/2 - faceCX) * scale, y: (image.height*0.42 - faceCY) * scale });
            } else { alert("æœªåµæ¸¬åˆ°äººè‡‰"); }
        } catch (e) { console.error(e); }
        setIsProcessing(false); setMsg('');
    };

    const runAIBGRemove = async () => {
        if (!image || !window.bodyPixModel) return;
        setMsg('AI æ™ºèƒ½å»èƒŒä¸­ï¼Œè«‹ç¨å€™...');
        setIsProcessing(true);
        try {
            // ä½¿ç”¨ Medium å…¼é¡§ç©©å®šèˆ‡æ•ˆèƒ½ï¼ŒThreshold èª¿ä½ç¢ºä¿æ·±è‰²è¡£ç‰©ä¸è¢«æ¶ˆå¤±
            const seg = await window.bodyPixModel.segmentPerson(image, { 
                internalResolution: 'medium', 
                segmentationThreshold: 0.6 
            });
            const tc = document.createElement('canvas'); 
            tc.width = image.width; tc.height = image.height;
            const ctx = tc.getContext('2d');
            ctx.drawImage(image, 0, 0);
            const imgData = ctx.getImageData(0, 0, tc.width, tc.height);
            
            for (let i = 0; i < imgData.data.length; i += 4) {
                const idx = (i/4);
                const x = idx % tc.width, y = Math.floor(idx / tc.width);
                if (!seg.data[idx]) {
                    imgData.data[i + 3] = 0;
                } else {
                    // å®‰å…¨ç¾½åŒ–ï¼šåŠ å…¥é‚Šç•Œæª¢æŸ¥é˜²è®€å– undefined
                    let isEdge = false;
                    if (x > 0 && x < tc.width - 1 && y > 0 && y < tc.height - 1) {
                        isEdge = !seg.data[idx-1] || !seg.data[idx+1] || !seg.data[idx-tc.width] || !seg.data[idx+tc.width];
                    }
                    if(isEdge) imgData.data[i+3] = 160;
                }
            }
            ctx.putImageData(imgData, 0, 0);
            const finalImg = new Image();
            finalImg.onload = () => { setImage(finalImg); setIsProcessing(false); setMsg(''); };
            finalImg.src = tc.toDataURL();
        } catch (e) {
            alert("å»èƒŒç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹é‡è©¦æˆ–æ‰‹å‹•èª¿æ•´");
            setIsProcessing(false); setMsg('');
        }
    };

    const draw = useCallback(() => {
        const canvas = canvasRef.current; if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = bgColor; ctx.fillRect(0, 0, 350, 450);
        if (image) {
            ctx.save(); ctx.translate(175 + p.x, 225 + p.y); ctx.scale(p.s, p.s);
            ctx.drawImage(image, -image.width / 2, -image.height / 2); ctx.restore();
        }
        if (suit.id) {
            const src = getClothesPath(suit.id);
            if (suitImg.current.src !== src) suitImg.current.src = src;
            if (suitImg.current.complete) {
                ctx.save(); ctx.translate(suit.x, suit.y); ctx.scale(suit.s * 1.5, suit.s * 1.5);
                ctx.drawImage(suitImg.current, -suitImg.current.width / 2, -suitImg.current.height / 2); ctx.restore();
            }
        }
    }, [image, p, suit, bgColor]);

    useEffect(() => { draw(); }, [draw]);
    useEffect(() => {
        const init = async () => {
            window.bodyPixModel = await bodyPix.load({ architecture: 'MobileNetV1', outputStride: 16, multiplier: 0.75 });
            window.faceModel = await blazeface.load();
        };
        init();
    }, []);

    return (
        <div className="max-w-6xl mx-auto flex flex-col lg:flex-row gap-8 pb-32">
            <div className="w-full lg:w-[450px] flex flex-col items-center">
                <div 
                    className="canvas-container w-full aspect-[35/45] select-none shadow-xl"
                    onTouchStart={(e)=>{
                        if(!suit.id) return;
                        if(e.touches.length===2) lastDist.current=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                        else { isDragging.current=true; lastPos.current={x:e.touches[0].clientX, y:e.touches[0].clientY}; }
                    }}
                    onTouchMove={(e)=>{
                        if(!suit.id) return; if(e.cancelable) e.preventDefault();
                        if(e.touches.length===2){
                            const dist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                            if(lastDist.current>0) setSuit(prev=>({...prev, s:Math.min(Math.max(prev.s*(dist/lastDist.current),0.1),0.9)}));
                            lastDist.current=dist;
                        } else if(isDragging.current){
                            const dx=e.touches[0].clientX-lastPos.current.x, dy=e.touches[0].clientY-lastPos.current.y;
                            const rect=canvasRef.current.getBoundingClientRect();
                            setSuit(prev=>({...prev, x:prev.x+dx*(350/rect.width), y:prev.y+dy*(450/rect.height)}));
                            lastPos.current={x:e.touches[0].clientX, y:e.touches[0].clientY};
                        }
                    }}
                    onTouchEnd={()=>{isDragging.current=false; lastDist.current=0;}}
                >
                    {isCam && <video ref={videoRef} autoPlay playsInline className="absolute inset-0 w-full h-full object-cover scale-x-[-1] z-20" />}
                    <canvas ref={canvasRef} width={350} height={450} />
                    <div className="id-guide"></div>
                    <div className="absolute top-5 right-5 flex flex-col gap-4 bg-white/50 p-2 rounded-full backdrop-blur-md z-30">
                        {['white','#007bff','#ff0000'].map(c => (
                            <div key={c} onClick={()=>setBgColor(c)} className={`bg-dot ${bgColor===c?'active':''}`} style={{backgroundColor:c}}></div>
                        ))}
                    </div>
                    {isProcessing && (
                        <div className="absolute inset-0 bg-slate-900/40 backdrop-blur-sm flex flex-col items-center justify-center text-white z-40">
                            <div className="animate-spin rounded-full h-10 w-10 border-4 border-white border-t-transparent mb-4"></div>
                            <span className="font-bold text-sm tracking-widest">{msg}</span>
                        </div>
                    )}
                </div>

                <div className="w-full mt-6 grid grid-cols-2 gap-3">
                    <button onClick={async ()=>{
                        if(isCam){
                            const safeImg = await makeSafeImage(videoRef.current);
                            setImage(safeImg); setIsCam(false);
                        } else {
                            setIsCam(true); navigator.mediaDevices.getUserMedia({video:{facingMode:'user'}}).then(s=>videoRef.current.srcObject=s);
                        }
                    }} className="bg-slate-900 text-white py-4 rounded-2xl font-black">{isCam?'ğŸ“¸ é»æ“Šæ‹ç…§':'ğŸ“· ç›¸æ©Ÿæ‹ç…§'}</button>
                    
                    <label className="bg-white border-2 border-slate-900 py-4 rounded-2xl font-black text-center cursor-pointer shadow-sm">ä¸Šå‚³æª”æ¡ˆ<input type="file" className="hidden" onChange={async (e)=>{
                        const file=e.target.files[0]; if(!file) return;
                        const tempImg = new Image();
                        tempImg.onload = async () => { const safe = await makeSafeImage(tempImg); setImage(safe); };
                        tempImg.src = URL.createObjectURL(file);
                    }} accept="image/*"/></label>

                    <button onClick={runAutoAlign} className="bg-blue-600 text-white py-4 rounded-2xl font-black text-sm shadow-lg shadow-blue-100">ğŸ¯ AI è‡ªå‹•å°é½Šäººåƒ</button>
                    <button onClick={runAIBGRemove} className="bg-white border-2 border-blue-600 text-blue-600 py-4 rounded-2xl font-black text-sm">âœ¨ åŸ·è¡Œ AI å»èƒŒ (é¸ç”¨)</button>
                </div>
            </div>

            <div className="flex-1 space-y-6">
                <div className="bg-white p-6 md:p-8 rounded-[40px] shadow-sm border border-slate-200 space-y-8">
                    <h2 className="text-xl font-black border-b pb-4 flex justify-between items-center">
                        æ§åˆ¶é¢æ¿ <span className="text-slate-300 text-[10px] tracking-widest uppercase">Performance Mode</span>
                    </h2>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <section className="space-y-6">
                            <h3 className="text-[10px] font-black text-slate-400 uppercase tracking-widest">äººåƒæ‰‹å‹•å¾®èª¿</h3>
                            <div className="space-y-8 px-1">
                                <div className="space-y-3">
                                    <div className="flex justify-between text-xs font-bold"><span>äººç‰©æ¯”ä¾‹</span><span className="text-blue-600">{(p.s*100).toFixed(0)}%</span></div>
                                    <input type="range" min="0.3" max="1.5" step="0.01" value={p.s} onChange={e=>setP({...p,s:parseFloat(e.target.value)})} />
                                </div>
                                <div className="space-y-3">
                                    <div className="flex justify-between text-xs font-bold"><span>å‚ç›´ä½ç½®</span><span className="text-blue-600">{p.y.toFixed(0)}</span></div>
                                    <input type="range" min="-200" max="200" value={p.y} onChange={e=>setP({...p,y:parseInt(e.target.value)})} />
                                </div>
                            </div>
                        </section>

                        <section className="space-y-4">
                            <h3 className="text-[10px] font-black text-blue-500 uppercase tracking-widest">æœè£æ›¿æ› (æ”¯æ´å…©æŒ‡ç¸®æ”¾)</h3>
                            <div className="flex gap-3 overflow-x-auto pb-4 no-scrollbar">
                                {['m1','m2','m3','m4','m5'].map(n=>(
                                    <div key={n} onClick={()=>setSuit({...suit, id:n})} className={`p-2 rounded-xl border-2 shrink-0 transition-all ${suit.id===n?'border-blue-600 bg-blue-50 scale-105':'border-slate-50 opacity-60'}`}>
                                        <img src={getClothesPath(n)} className="w-14 h-14 object-contain" />
                                    </div>
                                ))}
                                <button onClick={()=>setSuit({...suit, id:null})} className="px-5 border-2 border-dashed border-red-100 text-red-400 font-bold text-[10px] rounded-xl shrink-0 hover:bg-red-50">æ¸…é™¤</button>
                            </div>
                            <p className="text-[9px] text-slate-400">æç¤ºï¼šé¸å–è¡£æœå¾Œå¯åœ¨é è¦½å€ç”¨å…©æŒ‡æ‰‹å‹¢èª¿æ•´å¤§å°ã€‚</p>
                        </section>
                    </div>

                    <div className="pt-6 border-t flex flex-col gap-4">
                        <div className="flex gap-2 p-1 bg-slate-100 rounded-2xl">
                            {[['MIXED','1+2å‹æ··åˆ'],['TWO','ç´” 2 å‹'],['ONE','ç´” 1 å‹']].map(([k,v])=>(
                                <button key={k} onClick={()=>setMode(k)} className={`flex-1 py-4 rounded-xl font-black text-xs transition-all ${mode===k?'bg-white text-blue-600 shadow-md':'text-slate-400'}`}>{v}</button>
                            ))}
                        </div>
                        <button onClick={()=>{
                            const pc=document.createElement('canvas'); const ctx=pc.getContext('2d');
                            pc.width=1800; pc.height=1200; ctx.fillStyle="white"; ctx.fillRect(0,0,1800,1200);
                            const drawGrid=(cols,rows,w,h,sX,sY,gX,gY)=>{
                                for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
                                    const x=sX+c*(w+gX), y=sY+r*(h+gY);
                                    ctx.drawImage(canvasRef.current,0,0,350,450,x,y,w,h);
                                    ctx.strokeStyle="#cbd5e1"; ctx.lineWidth=1; ctx.strokeRect(x,y,w,h);
                                }
                            };
                            if(mode==='MIXED'){ drawGrid(4,1,413,531,80,80,15,0); drawGrid(5,1,331,449,80,650,10,0); }
                            else if(mode==='TWO') drawGrid(4,2,413,531,80,80,20,30);
                            else drawGrid(5,2,331,449,80,100,15,30);
                            const a=document.createElement('a'); a.download=`EzID_Stable_v176.png`; a.href=pc.toDataURL('image/png'); a.click();
                        }} className="w-full bg-blue-600 text-white py-6 rounded-[32px] font-black text-xl shadow-2xl active:scale-95 transition-all">ğŸ’¾ ä¸‹è¼‰æ’ç‰ˆæª”æ¡ˆ (4x6 å‹)</button>
                    </div>
                </div>
            </div>
        </div>
    );
};

ReactDOM.createRoot(document.getElementById('root')).render(<EzIDApp />);
</script>
</body>
</html>
