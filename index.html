<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EzID v20.47.60</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: sans-serif; background: #020617; color: #f8fafc; margin: 0; overflow-x: hidden; }
        #root { width: 100%; max-width: 500px; margin: 0 auto; min-height: 100vh; padding: 15px; }
        .zone-box { background: rgba(30, 41, 59, 0.4); border-radius: 24px; border: 1px solid rgba(255,255,255,0.05); padding: 16px; margin-bottom: 12px; }
        .zone-tag { font-size: 10px; font-weight: 900; color: #3b82f6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
        .stage-box { position: relative; width: 100%; aspect-ratio: 350/450; background: #fff; border-radius: 16px; overflow: hidden; touch-action: none; }
        .guide-circle { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 70%; height: 65%; border: 2px dashed rgba(59, 130, 246, 0.4); border-radius: 50%; pointer-events: none; z-index: 10; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
    </style>
</head>
<body>
    <div id="root"></div>

<script type="text/babel">
const { useState, useRef, useEffect, useMemo } = React;

// =======================================================
// [Zone 1: Spec Engine] - è¦æ ¼åŸ·æ³•èˆ‡é©—è­‰å±¤
// =======================================================
// å®šç¾©é‚è¼¯ä¸–ç•ŒåŸºæº–ï¼šæ‰€æœ‰ç·¨è¼¯æ“ä½œéƒ½åœ¨ 600x800 çš„ä¸–ç•Œä¸­é€²è¡Œ
const LOGICAL_BASE = { w: 600, h: 800 };

const RAW_SPECS = {
    '4x6-8':   { id: '4x6-8',   w: 1800, h: 1200, grid: [2, 4], size: [413, 531], count: 8, name: '2å‹(8å¼µ)', cat: '4x6' },
    '4x6-10':  { id: '4x6-10',  w: 1800, h: 1200, grid: [2, 5], size: [295, 413], count: 10, name: '1å‹(10å¼µ)', cat: '4x6' },
    '4x6-12':  { id: '4x6-12',  w: 1800, h: 1200, grid: [3, 4], size: [295, 413], count: 12, name: '1å‹(12å¼µ)', cat: '4x6' },
    '4x6-BIG': { id: '4x6-BIG', w: 1800, h: 1200, grid: [2, 3], size: [531, 708], count: 6, name: 'å¤§é ­ç…§(6å¼µ)', cat: '4x6' },
    '4x6-MIX': { id: '4x6-MIX', w: 1800, h: 1200, name: '1+2å‹(8å¼µ)', cat: '4x6', total: 8, sections: [{ x: 0, grid: [2, 2], size: [450, 600], count: 4, w: 900, h: 1200 }, { x: 900, grid: [2, 2], size: [413, 531], count: 4, w: 900, h: 1200 }] },
    '4x6-B':   { id: '4x6-B',   w: 1800, h: 1200, grid: [2, 4], size: [354, 472], count: 8, name: 'Bç‰ˆ(8å¼µ)', cat: '4x6' },
    'A4-20':   { id: 'A4-20',   w: 2480, h: 3508, grid: [5, 4], size: [413, 531], count: 20, name: 'A4-2å‹(20å¼µ)', cat: 'A4' },
    'A4-42':   { id: 'A4-42',   w: 2480, h: 3508, grid: [7, 6], size: [295, 413], count: 42, name: 'A4-1å‹(42å¼µ)', cat: 'A4' },
    'A4-ID':   { id: 'A4-ID',   w: 2480, h: 3508, grid: [4, 4], size: [450, 600], count: 16, name: 'A4-è­·ç…§(16å¼µ)', cat: 'A4' },
    'A4-BIG':  { id: 'A4-BIG',  w: 2480, h: 3508, grid: [4, 3], size: [531, 708], count: 12, name: 'A4-å¤§é ­(12å¼µ)', cat: 'A4' },
    'A4-B':    { id: 'A4-B',    w: 2480, h: 3508, grid: [6, 5], size: [354, 472], count: 30, name: 'A4-Bç‰ˆ(30å¼µ)', cat: 'A4' },
    'NAME':    { id: 'NAME',    w: 2480, h: 3508, grid: [6, 4], size: [295, 413], count: 24, name: 'å·¥ç‰Œ(24å¼µ)', cat: 'A4' },
    'A4-MIX':  { id: 'A4-MIX',  w: 2480, h: 3508, name: 'A4-1+2å‹(30å¼µ)', cat: 'A4', total: 30, sections: [{ y: 0, grid: [3, 4], size: [413, 531], count: 12, w: 2480, h: 1754 }, { y: 1754, grid: [3, 6], size: [295, 413], count: 18, w: 2480, h: 1754 }] }
};

const SpecEngine = {
    validate(s) {
        // [Safety Check 1] ç¢ºä¿å¿…è¦æ¬„ä½å­˜åœ¨
        if (!s.w || !s.h) throw new Error(`Spec ${s.id} missing geometry`);
        
        const gen = (sec) => {
            const arr = [];
            // [Safety Check 2] ç¢ºä¿ gap è¨ˆç®—ä¸æœƒç”¢ç”Ÿ NaN æˆ–è² æ•¸ (ç°¡å–®é˜²å‘†)
            const gx = ((sec.w || s.w) - sec.grid[1] * sec.size[0]) / (sec.grid[1] + 1);
            const gy = ((sec.h || s.h) - sec.grid[0] * sec.size[1]) / (sec.grid[0] + 1);
            
            for(let r=0; r<sec.grid[0]; r++) for(let c=0; c<sec.grid[1]; c++) {
                // [Safety Check 3] ä¸å¾—ç”Ÿæˆè¶…éé æœŸ count çš„ slot
                if(arr.length < (sec.count || 999)) {
                    const slot = { 
                        x: (sec.x || 0) + gx + c * (sec.size[0] + gx), 
                        y: (sec.y || 0) + gy + r * (sec.size[1] + gy), 
                        w: sec.size[0], 
                        h: sec.size[1] 
                    };
                    // [Safety Check 4] é‚Šç•Œæª¢æŸ¥
                    if (slot.x + slot.w > s.w + 1 || slot.y + slot.h > s.h + 1) {
                         console.error(`Spec ${s.id} slot out of bounds`, slot); // å¯¦éš›ç”¢å“æ‡‰ throw error
                    }
                    arr.push(slot);
                }
            }
            return arr;
        };

        const slots = s.sections ? s.sections.flatMap(gen) : gen(s);
        
        // [Safety Check 5] ç¸½æ•¸é©—è­‰
        const expectedCount = s.total || s.count;
        if (expectedCount && slots.length !== expectedCount) {
             throw new Error(`Spec ${s.id} integrity fail: expected ${expectedCount}, got ${slots.length}`);
        }

        return { ...s, slots };
    }
};

// å•Ÿå‹•æ™‚ç«‹å³åŸ·è¡Œå…¨è¦æ ¼é©—è­‰ (Fail Fast)
const SPECS = (() => {
    try {
        const validated = Object.fromEntries(Object.entries(RAW_SPECS).map(([k,v]) => [k, SpecEngine.validate(v)]));
        if (Object.keys(validated).length !== 12) throw new Error("Missing specs");
        return validated;
    } catch (e) {
        alert(`FATAL: Spec Validation Failed - ${e.message}`);
        throw e;
    }
})();

// =======================================================
// [Zone 2: è³‡æºç®¡ç†å±¤]
// =======================================================
const SUITS = {
    female: Array.from({length: 5}, (_, i) => `https://raw.githubusercontent.com/HPL1130/EzID-Taiwan/main/clothes/female/f${i+1}.png`),
    male: Array.from({length: 5}, (_, i) => `https://raw.githubusercontent.com/HPL1130/EzID-Taiwan/main/clothes/male/m${i+1}.png`)
};

const AssetCache = {
    pool: new Map(),
    async load(url) {
        if (this.pool.has(url)) return this.pool.get(url);
        return new Promise(res => {
            const i = new Image(); i.crossOrigin = "anonymous";
            i.onload = () => { this.pool.set(url, i); res(i); }; i.src = url;
        });
    }
};

function App() {
    // =======================================================
    // [Zone 3: ç‹€æ…‹èˆ‡ç‰©ç†å±¤] - é‚è¼¯åº§æ¨™ç³» (600x800)
    // =======================================================
    const [scene, setScene] = useState({
        layers: [
            { id: 'photo', x: 0, y: 0, s: 1, f: 1, img: null, visible: true },
            { id: 'suit', x: 0, y: 150, s: 1, f: 1, img: null, visible: true }
        ],
        activeId: 'photo'
    });
    const [ui, setUi] = useState({ cat: '4x6', spec: '4x6-8', mode: 'single', gender: 'female', results: null });
    const [history, setHistory] = useState([]);

    const cvsRef = useRef(null);
    const renderRequest = useRef(true);

    // Auto-Fit: ç¢ºä¿åœ–ç‰‡ "Cover" æ•´å€‹é‚è¼¯ç•«å¸ƒ (600x800)ï¼Œè€Œéåªå°é«˜åº¦
    const fitImage = (img) => {
        const scaleW = LOGICAL_BASE.w / img.width;
        const scaleH = LOGICAL_BASE.h / img.height;
        const scale = Math.max(scaleW, scaleH); // å–å¤§è€…ä»¥è¦†è“‹
        return { img, x: 0, y: 0, s: scale, f: 1 };
    };

    // =======================================================
    // [Zone 4: æ¸²æŸ“å¼•æ“å±¤] - åº§æ¨™ä¸€è‡´æ€§æ ¸å¿ƒ
    // =======================================================
    const RenderEngine = {
        // æ ¸å¿ƒé‚è¼¯ï¼šè¼¸å…¥é‚è¼¯åº§æ¨™ï¼Œè¼¸å‡ºåˆ°ç›®æ¨™ Canvas (targetRect)
        drawScene(ctx, layers, targetRect) {
            ctx.save();
            // 1. æ¸…ç©ºèˆ‡è£åˆ‡ç›®æ¨™å€åŸŸ
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(targetRect.x, targetRect.y, targetRect.w, targetRect.h);
            ctx.beginPath(); 
            ctx.rect(targetRect.x, targetRect.y, targetRect.w, targetRect.h); 
            ctx.clip();

            // 2. è¨ˆç®—æŠ•å½±æ¯”ç‡ï¼šç›®æ¨™å¯¬åº¦ / é‚è¼¯å¯¬åº¦ (600)
            const projectionScale = targetRect.w / LOGICAL_BASE.w;

            layers.forEach(l => {
                if (!l.visible || !l.img) return;
                ctx.save();
                // 3. åº§æ¨™è½‰æ›ï¼šLogic -> Target
                // Center + (LayerPos * Projection)
                const tx = targetRect.x + targetRect.w/2 + l.x * projectionScale;
                const ty = targetRect.y + targetRect.h/2 + l.y * projectionScale;
                
                ctx.translate(tx, ty);
                ctx.scale(l.s * projectionScale * l.f, l.s * projectionScale);
                ctx.drawImage(l.img, -l.img.width/2, -l.img.height/2);
                ctx.restore();
            });
            ctx.restore();
        }
    };

    useEffect(() => {
        let frame;
        const tick = () => {
            if (renderRequest.current && cvsRef.current) {
                const ctx = cvsRef.current.getContext('2d', { alpha: false });
                // UI æ¸²æŸ“ï¼šå°‡ 600x800 æŠ•å½±åˆ° 350x450 (æœƒæœ‰è¼•å¾®é•·å¯¬æ¯”å·®ç•°ï¼Œä½†ä»¥å¯¬åº¦ç‚ºåŸºæº–)
                // ç‚ºäº†ä¸è®“ UI è®Šå½¢ï¼Œæˆ‘å€‘ä¿æŒå¯¬åº¦åŸºæº–ï¼Œé«˜åº¦è‡ªå‹•å»¶ä¼¸æˆ–è£åˆ‡
                RenderEngine.drawScene(ctx, scene.layers, {x:0, y:0, w:350, h:466}); // 350 * (800/600) ~= 466
                renderRequest.current = false;
            }
            frame = requestAnimationFrame(tick);
        };
        frame = requestAnimationFrame(tick);
        return () => cancelAnimationFrame(frame);
    }, [scene]);

    // =======================================================
    // [Zone 5: äº’å‹•èˆ‡æ‰‹å‹¢å±¤] - æ˜ å°„å›é‚è¼¯åº§æ¨™
    // =======================================================
    const interact = useRef({ isDown: false, lastX: 0, lastY: 0, lastD: 0, startS: 1 });

    const handlePointer = (e, type) => {
        if (e.cancelable) e.preventDefault();
        const t = scene.activeId;
        // è¨ˆç®— UI -> Logic çš„é€†å‘æ¯”ç‡
        // UI Width = 350, Logic Width = 600 => Ratio = 350/600
        // Delta Logic = Delta UI / Ratio = Delta UI * (600/350)
        const logicRatio = LOGICAL_BASE.w / 350; 

        const pts = e.targetTouches || [{ clientX: e.clientX, clientY: e.clientY }];
        
        if (type === 'start') {
            interact.current.isDown = true;
            if (pts.length >= 2) {
                interact.current.lastD = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY);
                interact.current.startS = scene.layers.find(l => l.id === t).s;
            } else {
                interact.current.lastX = pts[0].clientX; interact.current.lastY = pts[0].clientY;
            }
        } else if (type === 'move' && interact.current.isDown) {
            setScene(prev => {
                const layers = prev.layers.map(l => {
                    if (l.id !== t) return l;
                    if (pts.length >= 2) {
                        const d = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY);
                        return { ...l, s: Math.max(0.1, Math.min(5, interact.current.startS * (d / interact.current.lastD))) };
                    } else {
                        // è½‰æ›è¢å¹•ä½ç§»åˆ°é‚è¼¯ä½ç§»
                        const dx = (pts[0].clientX - interact.current.lastX) * logicRatio;
                        const dy = (pts[0].clientY - interact.current.lastY) * logicRatio;
                        interact.current.lastX = pts[0].clientX; interact.current.lastY = pts[0].clientY;
                        return { ...l, x: l.x + dx, y: l.y + dy };
                    }
                });
                renderRequest.current = true;
                return { ...prev, layers };
            });
        } else { interact.current.isDown = false; }
    };

    // =======================================================
    // [Zone 6: å°å‡ºèˆ‡ä»‹é¢å±¤] - æ‰¹æ¬¡ç”Ÿç”¢èˆ‡æ ¡é©—
    // =======================================================
    const doExport = async (all) => {
        const list = all ? Object.keys(SPECS) : [ui.spec];
        const res = [];
        
        // å»ºç«‹ä¸€å€‹ "Master" ç•«å¸ƒï¼Œå°ºå¯¸å°±æ˜¯æˆ‘å€‘çš„é‚è¼¯åŸºæº–
        const master = document.createElement('canvas'); 
        master.width = LOGICAL_BASE.w; 
        master.height = LOGICAL_BASE.h;
        const mCtx = master.getContext('2d');

        for (const sid of list) {
            const spec = SPECS[sid];
            const canvas = document.createElement('canvas'); canvas.width = spec.w; canvas.height = spec.h;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = "#fff"; ctx.fillRect(0,0,spec.w,spec.h);
            
            for(let i=0; i<spec.slots.length; i++) {
                const slot = spec.slots[i];
                // å¤šäººæ¨¡å¼ä¸‹ï¼Œè‹¥è©² Slot æ²’æœ‰å°æ‡‰çš„ Historyï¼Œå‰‡ä½¿ç”¨ç•¶å‰ Scene
                // é€™æ˜¯ "Fallback to current" çš„è¡Œç‚ºï¼Œä¹Ÿå¯è¨­è¨ˆç‚ºç•™ç™½
                const targetLayers = (ui.mode === 'multi' && history[i]) ? history[i].layers : scene.layers;
                
                // 1. æ¸²æŸ“åˆ° Master (1:1 Logic Scale)
                RenderEngine.drawScene(mCtx, targetLayers, {x:0, y:0, w:LOGICAL_BASE.w, h:LOGICAL_BASE.h});
                
                // 2. è¤‡è£½åˆ° Slot (ä¸è«– Slot æ˜¯ 1å‹é‚„2å‹ï¼Œå…§å®¹éƒ½æ˜¯ä¾†è‡ª Master)
                ctx.drawImage(master, 0, 0, LOGICAL_BASE.w, LOGICAL_BASE.h, slot.x, slot.y, slot.w, slot.h);
            }
            res.push({ url: canvas.toDataURL('image/jpeg', 0.8), name: spec.name, id: sid });
            await new Promise(r => requestAnimationFrame(r));
        }
        setUi(u => ({...u, results: res}));
    };

    return (
        <div className="flex flex-col gap-3">
            <header className="flex justify-between items-center px-1">
                <h1 className="text-2xl font-black italic text-blue-500">EzID</h1>
                <span className="text-[10px] font-bold text-slate-500 bg-slate-800 px-2 py-1 rounded text-white">V20.47.60</span>
            </header>

            <div className="zone-box">
                <div className="zone-tag">ğŸ‘¥ æ¨¡å¼èˆ‡è¦æ ¼ (Verified)</div>
                <div className="flex gap-2 mb-3">
                    <button onClick={() => setUi(u => ({...u, mode: 'single'}))} className={`flex-1 py-3 rounded-2xl text-xs font-black ${ui.mode === 'single' ? 'bg-blue-600' : 'bg-slate-800 text-slate-500'}`}>å–®äººæ¨¡å¼</button>
                    <button onClick={() => setUi(u => ({...u, mode: 'multi'}))} className={`flex-1 py-3 rounded-2xl text-xs font-black ${ui.mode === 'multi' ? 'bg-purple-600' : 'bg-slate-800 text-slate-500'}`}>å¤šäººæ¨¡å¼</button>
                </div>
                <div className="flex gap-2 overflow-x-auto no-scrollbar pb-2">
                    {['4x6', 'A4'].map(c => (
                        <button key={c} onClick={() => setUi(u => ({...u, cat: c}))} className={`px-6 py-2 rounded-xl text-xs font-black flex-shrink-0 ${ui.cat === c ? 'bg-white text-black' : 'bg-slate-800 text-slate-500'}`}>{c}</button>
                    ))}
                </div>
                <div className="flex flex-wrap gap-1">
                    {Object.values(SPECS).filter(s => s.cat === ui.cat).map(s => (
                        <button key={s.id} onClick={() => setUi(u => ({...u, spec: s.id}))} className={`px-2 py-2.5 rounded-lg text-[10px] font-bold flex-1 min-w-[85px] ${ui.spec === s.id ? 'bg-blue-600' : 'bg-slate-800 text-slate-500'}`}>{s.name}</button>
                    ))}
                </div>
            </div>

            <div className="zone-box">
                <div className="zone-tag">ğŸ“¸ å½±åƒè¼‰å…¥ (Auto-Cover)</div>
                <label className="block w-full py-4 bg-white text-black text-center rounded-2xl font-black text-xs cursor-pointer mb-3">é¸å–æª”æ¡ˆ<input type="file" hidden accept="image/*" onChange={async e => {
                    const f = e.target.files[0]; if(!f) return;
                    const img = await AssetCache.load(URL.createObjectURL(f));
                    const fitData = fitImage(img);
                    setScene(s => ({...s, layers: s.layers.map(l => l.id === 'photo' ? {...l, ...fitData} : l)}));
                    renderRequest.current = true;
                }}/></label>
                {ui.mode === 'multi' && (
                    <div className="pt-3 border-t border-slate-700/50">
                        <button onClick={() => {
                            const thumb = cvsRef.current.toDataURL('image/jpeg', 0.1);
                            setHistory(prev => [...prev.slice(-11), { thumb, layers: JSON.parse(JSON.stringify(scene.layers)) }]);
                        }} className="w-full py-4 bg-purple-600 rounded-2xl font-black text-xs mb-3">ä¿å­˜ç•¶å‰äººç‰©</button>
                        <div className="flex gap-2 overflow-x-auto no-scrollbar">
                            {history.map((h, i) => (
                                <img key={i} src={h.thumb} onClick={() => { setScene(s => ({...s, layers: h.layers})); renderRequest.current=true; }} className="w-12 h-12 rounded-lg border-2 border-slate-800 flex-shrink-0" />
                            ))}
                        </div>
                    </div>
                )}
            </div>

            <div className="zone-box">
                <div className="zone-tag">ğŸ•¹ï¸ ç·¨è¼¯å™¨ (Logic Coords)</div>
                <div className="stage-box mb-4" onPointerDown={e => handlePointer(e, 'start')} onPointerMove={e => handlePointer(e, 'move')} onPointerUp={e => handlePointer(e, 'end')}>
                    <canvas ref={cvsRef} width="350" height="466" className="w-full h-full" />
                    <div className="guide-circle"></div>
                </div>
                <div className="flex gap-2 mb-3">
                    {scene.layers.map(l => (
                        <button key={l.id} onClick={() => setScene(s => ({...s, activeId: l.id}))} className={`flex-1 py-3 rounded-xl text-xs font-black ${scene.activeId === l.id ? 'bg-blue-600' : 'bg-slate-800 text-slate-500'}`}>{l.id === 'photo' ? 'äººç‰©' : 'è¡£æœ'}</button>
                    ))}
                </div>
                <div className="flex gap-2 mb-3">
                    <button onClick={() => setUi(u => ({...u, gender: 'female'}))} className={`flex-1 py-2 rounded-lg text-xs font-bold ${ui.gender === 'female' ? 'bg-indigo-600' : 'bg-slate-800 text-slate-500'}`}>å¥³è£</button>
                    <button onClick={() => setUi(u => ({...u, gender: 'male'}))} className={`flex-1 py-2 rounded-lg text-xs font-bold ${ui.gender === 'male' ? 'bg-indigo-600' : 'bg-slate-800 text-slate-500'}`}>ç”·è£</button>
                </div>
                <div className="flex gap-2 overflow-x-auto no-scrollbar">
                    {SUITS[ui.gender].map(url => (
                        <img key={url} src={url} onClick={async () => {
                            const img = await AssetCache.load(url);
                            setScene(s => ({...s, layers: s.layers.map(l => l.id === 'suit' ? {...l, img} : l)}));
                            renderRequest.current = true;
                        }} className="w-10 h-10 bg-white rounded-lg p-1 border border-slate-700 flex-shrink-0" />
                    ))}
                </div>
            </div>

            <div className="grid grid-cols-2 gap-2 mb-10">
                <button onClick={() => doExport(false)} className="py-5 bg-blue-600 rounded-2xl font-black text-xs text-white">å°å‡ºå–®å¼µ</button>
                <button onClick={() => doExport(true)} className="py-5 bg-orange-600 rounded-2xl font-black text-xs text-white">å…¨è¦æ ¼å°å‡º</button>
            </div>

            {ui.results && (
                <div className="fixed inset-0 bg-slate-950 z-[999] overflow-y-auto p-4 pb-24">
                    {ui.results.map((r, i) => (
                        <div key={i} className="mb-6 bg-slate-900 p-4 rounded-3xl border border-slate-800 text-center">
                            <p className="text-[10px] text-slate-500 font-bold mb-2">{r.name}</p>
                            <img src={r.url} className="w-full rounded-xl mb-3 shadow-2xl" />
                            <a href={r.url} download={`EzID_${r.id}.jpg`} className="inline-block px-10 py-4 bg-blue-600 rounded-2xl text-xs font-black text-white">ä¸‹è¼‰æ­¤å¼µ</a>
                        </div>
                    ))}
                    <button onClick={() => setUi(u => ({...u, results: null}))} className="fixed bottom-6 left-1/2 -translate-x-1/2 w-48 py-4 bg-white text-black rounded-full font-black">è¿”å›ç·¨è¼¯</button>
                </div>
            )}
        </div>
    );
}
ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
