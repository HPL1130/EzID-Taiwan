<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>EzID Taiwan v1.8.0 - å°ˆæ¥­ç”Ÿç”¢åŠ›ç‰ˆ</title>
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0/dist/body-pix.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
<style>
    body { background-color: #f1f5f9; color: #1f2937; font-family: system-ui, -apple-system, sans-serif; -webkit-tap-highlight-color: transparent; }
    .canvas-container { position: relative; touch-action: none; background: #cbd5e1; border-radius: 28px; overflow: hidden; border: 6px solid #fff; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.15); }
    canvas { width: 100%; height: auto; display: block; background: white; }
    .id-guide { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -55%); width: 62%; height: 62%; border: 2px dashed rgba(239, 68, 68, 0.35); border-radius: 50%; pointer-events: none; z-index: 10; }
    input[type=range] { -webkit-appearance: none; width: 100%; height: 6px; background: #e2e8f0; border-radius: 10px; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%; background: #2563eb; border: 3px solid white; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); cursor: pointer; }
    .bg-dot { width: 36px; height: 36px; border-radius: 50%; cursor: pointer; border: 3px solid white; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 0 0 1px #e2e8f0; }
    .bg-dot.active { transform: scale(1.2); box-shadow: 0 0 0 3px #2563eb; }
    .no-scrollbar::-webkit-scrollbar { display: none; }
</style>
</head>
<body class="p-4 md:p-10">
<div id="root"></div>

<script type="text/babel">
const { useState, useRef, useEffect, useCallback } = React;

const APP_VERSION = '1.8.0';
const BG_PRESETS = [
    { name: 'ç™½è‰²', color: '#ffffff' },
    { name: 'æ¨™æº–è—', color: '#0b3c89' },
    { name: 'ç†±æƒ…ç´…', color: '#b11226' }
];

const EzIDApp = () => {
    const [image, setImage] = useState(null);
    const [isCam, setIsCam] = useState(false);
    const [aiReady, setAiReady] = useState(false);
    const [bgColor, setBgColor] = useState(BG_PRESETS[1].color);
    const [p, setP] = useState({ x: 0, y: 0, s: 0.7 });
    const [suit, setSuit] = useState({ id: null, x: 175, y: 340, s: 0.35 });
    const [isProcessing, setIsProcessing] = useState(false);
    const [statusMsg, setStatusMsg] = useState('åˆå§‹åŒ–æ¨¡çµ„...');

    const canvasRef = useRef(null);
    const videoRef = useRef(null);
    const suitImg = useRef(new Image());
    const isDragging = useRef(false);
    const lastPos = useRef({ x: 0, y: 0 });
    const lastDist = useRef(0);

    // 1. ç›¸æ©Ÿè³‡æºé‡‹æ”¾èˆ‡ç”Ÿå‘½é€±æœŸ
    const stopCamera = useCallback(() => {
        if (videoRef.current && videoRef.current.srcObject) {
            videoRef.current.srcObject.getTracks().forEach(track => track.stop());
            videoRef.current.srcObject = null;
        }
    }, []);

    // 2. åˆå§‹åŒ– AI æ¨¡å‹
    useEffect(() => {
        (async () => {
            try {
                await tf.ready();
                window.bodyPixModel = await bodyPix.load({ architecture: 'MobileNetV1', outputStride: 16, multiplier: 0.75 });
                window.faceModel = await blazeface.load();
                setAiReady(true);
                setStatusMsg('');
            } catch (err) {
                console.error(err);
                setStatusMsg('æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯');
            }
        })();
        return () => stopCamera(); // Unmount æ™‚é‡‹æ”¾
    }, [stopCamera]);

    const draw = useCallback(() => {
        const canvas = canvasRef.current; if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = bgColor; ctx.fillRect(0, 0, 350, 450);
        if (image) {
            ctx.save(); ctx.translate(175 + p.x, 225 + p.y); ctx.scale(p.s, p.s);
            ctx.drawImage(image, -image.width / 2, -image.height / 2); ctx.restore();
        }
        if (suit.id) {
            const src = `${window.location.href.split('?')[0].replace(/\/[^\/]*$/, '')}/clothes/suit-${suit.id}.png`;
            if (suitImg.current.src !== src) suitImg.current.src = src;
            if (suitImg.current.complete) {
                ctx.save(); ctx.translate(suit.x, suit.y); ctx.scale(suit.s * 1.5, suit.s * 1.5);
                ctx.drawImage(suitImg.current, -suitImg.current.width / 2, -suitImg.current.height / 2); ctx.restore();
            }
        }
    }, [image, p, suit, bgColor]);

    // 3. RAF æ•ˆèƒ½å„ªåŒ–å¾ªç’°
    useEffect(() => {
        let raf;
        const loop = () => { draw(); raf = requestAnimationFrame(loop); };
        raf = requestAnimationFrame(loop);
        return () => cancelAnimationFrame(raf);
    }, [draw]);

    const makeSafeImage = (imgSource) => {
        return new Promise((resolve) => {
            const canvas = document.createElement('canvas');
            const w = imgSource.width || imgSource.videoWidth;
            const h = imgSource.height || imgSource.videoHeight;
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            if (imgSource.videoWidth) { ctx.translate(w, 0); ctx.scale(-1, 1); }
            ctx.drawImage(imgSource, 0, 0);
            const safeImg = new Image();
            safeImg.onload = () => resolve(safeImg);
            safeImg.src = canvas.toDataURL('image/png');
        });
    };

    const runAutoAlign = async () => {
        if (!image || !aiReady) return;
        setIsProcessing(true); setStatusMsg('æ­£åœ¨åˆ†æè‡‰éƒ¨...');
        try {
            const preds = await window.faceModel.estimateFaces(image, false);
            if (preds.length > 0) {
                const face = preds[0];
                const faceH = (face.bottomRight[1] - face.topLeft[1]);
                const scale = (350 * 0.45) / faceH;
                setP({ 
                    s: scale, 
                    x: (image.width/2 - (face.topLeft[0] + face.bottomRight[0])/2) * scale, 
                    y: (image.height*0.42 - (face.topLeft[1] + face.bottomRight[1])/2) * scale 
                });
            } else { alert("æœªåµæ¸¬åˆ°äººè‡‰ï¼Œè«‹æ‰‹å‹•ç¸®æ”¾èª¿æ•´ã€‚"); }
        } catch (e) { console.error(e); }
        setIsProcessing(false); setStatusMsg('');
    };

    const runAIBGRemove = async () => {
        if (!image || !aiReady) return;
        setIsProcessing(true); setStatusMsg('AI å»èƒŒé€²è¡Œä¸­ (ç´„ 5 ç§’)...');
        try {
            const seg = await window.bodyPixModel.segmentPerson(image, { internalResolution: 'medium', segmentationThreshold: 0.6 });
            const tc = document.createElement('canvas'); tc.width = image.width; tc.height = image.height;
            const ctx = tc.getContext('2d'); ctx.drawImage(image, 0, 0);
            const imgData = ctx.getImageData(0, 0, tc.width, tc.height);
            for (let i = 0; i < imgData.data.length; i += 4) {
                if (!seg.data[i/4]) imgData.data[i + 3] = 0;
            }
            ctx.putImageData(imgData, 0, 0);
            const finalImg = new Image();
            finalImg.onload = () => { setImage(finalImg); setIsProcessing(false); setStatusMsg(''); };
            finalImg.src = tc.toDataURL();
        } catch (e) { setIsProcessing(false); setStatusMsg(''); }
    };

    return (
        <div className="max-w-6xl mx-auto flex flex-col lg:flex-row gap-10 pb-32">
            <div className="w-full lg:w-[450px] flex flex-col items-center">
                <div 
                    className="canvas-container w-full aspect-[35/45] select-none"
                    onTouchStart={(e)=>{
                        if(!suit.id) return;
                        if(e.touches.length===2) lastDist.current=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                        else { isDragging.current=true; lastPos.current={x:e.touches[0].clientX, y:e.touches[0].clientY}; }
                    }}
                    onTouchMove={(e)=>{
                        if(!suit.id) return; if(e.cancelable) e.preventDefault();
                        if(e.touches.length===2){
                            const dist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                            if(lastDist.current>0) setSuit(prev=>({...prev, s:Math.min(Math.max(prev.s*(dist/lastDist.current),0.1),0.9)}));
                            lastDist.current=dist;
                        } else if(isDragging.current){
                            const dx=e.touches[0].clientX-lastPos.current.x, dy=e.touches[0].clientY-lastPos.current.y;
                            const rect=canvasRef.current.getBoundingClientRect();
                            setSuit(prev=>({...prev, x:prev.x+dx*(350/rect.width), y:prev.y+dy*(450/rect.height)}));
                            lastPos.current={x:e.touches[0].clientX, y:e.touches[0].clientY};
                        }
                    }}
                    onTouchEnd={()=>{isDragging.current=false; lastDist.current=0;}}
                >
                    {isCam && <video ref={videoRef} autoPlay playsInline className="absolute inset-0 w-full h-full object-cover scale-x-[-1] z-20" />}
                    <canvas ref={canvasRef} width={350} height={450} />
                    <div className="id-guide"></div>
                    <div className="absolute top-5 right-5 flex flex-col gap-4 bg-white/60 p-2 rounded-full backdrop-blur-md z-30">
                        {BG_PRESETS.map(preset => (
                            <div key={preset.color} onClick={()=>setBgColor(preset.color)} title={preset.name} className={`bg-dot ${bgColor===preset.color?'active':''}`} style={{backgroundColor:preset.color}}></div>
                        ))}
                    </div>
                    {(isProcessing || statusMsg) && (
                        <div className="absolute inset-0 bg-slate-900/60 backdrop-blur-sm flex flex-col items-center justify-center text-white z-40 transition-opacity">
                            <div className="w-10 h-10 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-4"></div>
                            <span className="font-bold text-sm tracking-widest">{statusMsg}</span>
                        </div>
                    )}
                </div>

                <div className="w-full mt-8 grid grid-cols-2 gap-4 px-2">
                    <button onClick={async ()=>{
                        if(isCam){
                            const safe = await makeSafeImage(videoRef.current);
                            setImage(safe); setIsCam(false); stopCamera();
                        } else {
                            setIsCam(true);
                            const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user'}});
                            videoRef.current.srcObject = stream;
                        }
                    }} className="bg-slate-900 text-white py-5 rounded-2xl font-black shadow-lg active:scale-95 transition-all">{isCam?'ğŸ“¸ æ•æ‰å¿«ç…§':'ğŸ“· ç›¸æ©Ÿæ‹ç…§'}</button>
                    
                    <label className="bg-white border-2 border-slate-900 py-5 rounded-2xl font-black text-center cursor-pointer shadow-md active:scale-95 transition-all overflow-hidden">
                        é¸æ“‡åœ–ç‰‡<input type="file" className="hidden" onChange={async (e)=>{
                            stopCamera(); setIsCam(false);
                            const file=e.target.files[0]; if(!file) return;
                            const tempImg = new Image();
                            tempImg.onload = async () => { const safe = await makeSafeImage(tempImg); setImage(safe); };
                            tempImg.src = URL.createObjectURL(file);
                        }} accept="image/*"/>
                    </label>

                    <button onClick={runAutoAlign} disabled={!aiReady} className="bg-blue-600 text-white py-4 rounded-2xl font-bold shadow-xl disabled:bg-slate-300">ğŸ¯ AI è‡ªå‹•å°é½Š</button>
                    <button onClick={runAIBGRemove} disabled={!aiReady} className="bg-white border-2 border-blue-600 text-blue-600 py-4 rounded-2xl font-bold disabled:border-slate-300 disabled:text-slate-300">âœ¨ AI æ™ºèƒ½å»èƒŒ</button>
                </div>
            </div>

            <div className="flex-1 space-y-8">
                <div className="bg-white p-8 md:p-12 rounded-[40px] shadow-sm border border-slate-100 space-y-10">
                    <div className="flex justify-between items-end border-b pb-6">
                        <h1 className="text-3xl font-black tracking-tighter">EzID <span className="text-blue-600">PRO</span></h1>
                        <span className="text-[10px] font-bold text-slate-400 bg-slate-50 px-3 py-1 rounded-full uppercase tracking-widest">Version {APP_VERSION}</span>
                    </div>

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-12">
                        <section className="space-y-6">
                            <h3 className="text-xs font-black text-slate-400 uppercase tracking-widest">äººç‰©å¾®èª¿</h3>
                            <div className="space-y-10">
                                <div className="space-y-3">
                                    <div className="flex justify-between text-xs font-bold"><span>äººç‰©æ¯”ä¾‹</span><span>{(p.s*100).toFixed(0)}%</span></div>
                                    <input type="range" min="0.3" max="1.5" step="0.01" value={p.s} onChange={e=>setP({...p,s:parseFloat(e.target.value)})} />
                                </div>
                                <div className="space-y-3">
                                    <div className="flex justify-between text-xs font-bold"><span>å‚ç›´ä½ç½®</span><span>{p.y.toFixed(0)}</span></div>
                                    <input type="range" min="-200" max="200" value={p.y} onChange={e=>setP({...p,y:parseInt(e.target.value)})} />
                                </div>
                            </div>
                        </section>

                        <section className="space-y-6">
                            <h3 className="text-xs font-black text-blue-500 uppercase tracking-widest">æœè£æ›¿æ› (æ”¯æ´å…©æŒ‡ç¸®æ”¾)</h3>
                            <div className="flex gap-4 overflow-x-auto pb-4 no-scrollbar">
                                {['m1','m2','m3','m4','m5'].map(n=>(
                                    <div key={n} onClick={()=>setSuit({...suit, id:n})} className={`p-3 rounded-2xl border-2 shrink-0 transition-all ${suit.id===n?'border-blue-600 bg-blue-50 scale-105':'border-slate-50 opacity-50 hover:opacity-100'}`}>
                                        <img src={`${window.location.href.split('?')[0].replace(/\/[^\/]*$/, '')}/clothes/suit-${n}.png`} className="w-16 h-16 object-contain" />
                                    </div>
                                ))}
                                <button onClick={()=>setSuit({...suit, id:null})} className="px-6 border-2 border-dashed border-red-200 text-red-500 font-bold text-xs rounded-2xl shrink-0 hover:bg-red-50">æ¸…é™¤æœè£</button>
                            </div>
                        </section>
                    </div>

                    <div className="pt-8 border-t space-y-6">
                        <p className="text-[10px] text-slate-400 text-center font-medium">â€» ä¸‹è¼‰æª”æ¡ˆæ ¼å¼ç‚º 1200x1800 åƒç´ ï¼Œç¬¦åˆ 4x6 å‹ç…§ç‰‡ 300 DPI æ²–å°æ¨™æº–ã€‚</p>
                        <button onClick={()=>{
                            const pc=document.createElement('canvas'); const ctx=pc.getContext('2d');
                            pc.width=1800; pc.height=1200; ctx.fillStyle="white"; ctx.fillRect(0,0,1800,1200);
                            const drawGrid=(cols,rows,w,h,sX,sY,gX,gY)=>{
                                for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
                                    const x=sX+c*(w+gX), y=sY+r*(h+gY);
                                    ctx.drawImage(canvasRef.current,0,0,350,450,x,y,w,h);
                                    ctx.strokeStyle="#e2e8f0"; ctx.lineWidth=1; ctx.strokeRect(x,y,w,h);
                                }
                            };
                            drawGrid(4,1,413,531,80,80,15,0); drawGrid(5,1,331,449,80,650,10,0);
                            const a=document.createElement('a'); a.download=`EzID_Output_4x6_300dpi.png`; a.href=pc.toDataURL('image/png'); a.click();
                        }} className="w-full bg-blue-600 text-white py-6 rounded-[32px] font-black text-xl shadow-2xl shadow-blue-200 active:scale-95 transition-all">ğŸ’¾ ä¸‹è¼‰å°ˆæ¥­æ’ç‰ˆæª”æ¡ˆ</button>
                    </div>
                </div>
            </div>
        </div>
    );
};

ReactDOM.createRoot(document.getElementById('root')).render(<EzIDApp />);
</script>
</body>
</html>
