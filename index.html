<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>EzID Taiwan v1.6.8 - å…¨å¹³å° AI è­‰ä»¶ç…§</title>
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0/dist/body-pix.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
<style>
    body { background-color: #f8fafc; color: #1e293b; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; -webkit-tap-highlight-color: transparent; }
    canvas { border-radius: 24px; max-width: 100%; height: auto; background: white; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15); border: 1px solid #e2e8f0; touch-action: none; cursor: move; }
    .guide-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -55%); width: 55%; height: 55%; border: 2px dashed rgba(239, 68, 68, 0.3); border-radius: 50%; pointer-events: none; }
    .bg-dot { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 3px solid white; box-shadow: 0 0 0 1px #cbd5e1; transition: all 0.2s; }
    .bg-dot.active { transform: scale(1.2); box-shadow: 0 0 0 2px #0f172a; }
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .control-panel { background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(10px); }
</style>
</head>
<body class="p-3 md:p-8 no-scrollbar">
<div id="root"></div>

<script type="text/babel">
const { useState, useRef, useEffect, useCallback } = React;

const EzIDApp = () => {
    // ç‹€æ…‹è¨­å®š
    const [image, setImage] = useState(null);
    const [isCam, setIsCam] = useState(false);
    const [mode, setMode] = useState('MIXED');
    const [bgColor, setBgColor] = useState('white');
    const [p, setP] = useState({ x: 0, y: 0, s: 0.7 }); // äººåƒ
    const [suit, setSuit] = useState({ id: null, x: 175, y: 340, s: 0.35 }); // è¡£æœ
    const [autoAlign, setAutoAlign] = useState(true);
    const [isProcessing, setIsProcessing] = useState(false);
    
    // Refs
    const bodyPixModel = useRef(null);
    const faceModel = useRef(null);
    const canvasRef = useRef(null);
    const videoRef = useRef(null);
    const suitImg = useRef(new Image());
    const isDragging = useRef(false);
    const lastPos = useRef({ x: 0, y: 0 });

    const getClothesPath = (id) => {
        const url = window.location.href.split('?')[0];
        const baseUrl = url.endsWith('/') ? url : url.substring(0, url.lastIndexOf('/') + 1);
        return `${baseUrl}clothes/suit-${id}.png`;
    };

    // æ‹–æ›³è™•ç†é‚è¼¯ (ç›¸å®¹æ»‘é¼ èˆ‡è§¸æ§)
    const handleDown = (e) => {
        if (!suit.id) return;
        isDragging.current = true;
        const x = e.touches ? e.touches[0].clientX : e.clientX;
        const y = e.touches ? e.touches[0].clientY : e.clientY;
        lastPos.current = { x, y };
    };

    const handleMove = (e) => {
        if (!isDragging.current || !suit.id) return;
        // é˜»æ­¢è¢å¹•æ²å‹•é˜²æ­¢å¹²æ“¾
        if (e.cancelable) e.preventDefault();
        
        const x = e.touches ? e.touches[0].clientX : e.clientX;
        const y = e.touches ? e.touches[0].clientY : e.clientY;
        
        const dx = x - lastPos.current.x;
        const dy = y - lastPos.current.y;

        const rect = canvasRef.current.getBoundingClientRect();
        const factorX = 350 / rect.width;
        const factorY = 450 / rect.height;

        setSuit(prev => ({
            ...prev,
            x: prev.x + dx * factorX,
            y: prev.y + dy * factorY
        }));

        lastPos.current = { x, y };
    };

    const handleUp = () => { isDragging.current = false; };

    // åˆå§‹åŒ–æ¨¡å‹
    useEffect(() => {
        const init = async () => {
            setIsProcessing(true);
            try {
                bodyPixModel.current = await bodyPix.load({ architecture: 'MobileNetV1', outputStride: 16, multiplier: 0.75 });
                faceModel.current = await blazeface.load();
            } catch (e) { console.error("æ¨¡å‹è¼‰å…¥å¤±æ•—", e); }
            setIsProcessing(false);
        };
        init();
    }, []);

    // è‡ªå‹•å°é½Šæ ¸å¿ƒ
    const performAutoAlign = (predictions, vw, vh) => {
        if (!predictions.length || isDragging.current) return;
        const face = predictions[0];
        const fW = face.bottomRight[0] - face.topLeft[0];
        const fCX = face.topLeft[0] + fW / 2;
        const fCY = face.topLeft[1] + (face.bottomRight[1] - face.topLeft[1]) / 2;
        const scale = (350 * 0.38) / fW;
        setP({
            x: (vw / 2 - fCX) * scale,
            y: (vh * 0.42 - fCY) * scale,
            s: Math.min(Math.max(scale, 0.4), 1.2)
        });
    };

    // æ¯ä¸€å¹€çš„å»èƒŒèˆ‡é‹ç®—
    const processFrame = async (source, isVideo) => {
        if (!bodyPixModel.current) return null;
        if (autoAlign && faceModel.current) {
            const pred = await faceModel.current.estimateFaces(source, false);
            if (pred.length) performAutoAlign(pred, isVideo ? source.videoWidth : source.width, isVideo ? source.videoHeight : source.height);
        }
        const seg = await bodyPixModel.current.segmentPerson(source, { internalResolution: 'medium', segmentationThreshold: 0.7 });
        const tc = document.createElement('canvas');
        tc.width = isVideo ? source.videoWidth : source.width;
        tc.height = isVideo ? source.videoHeight : source.height;
        const ctx = tc.getContext('2d');
        if (isVideo) { ctx.save(); ctx.translate(tc.width, 0); ctx.scale(-1, 1); ctx.drawImage(source, 0, 0); ctx.restore(); }
        else ctx.drawImage(source, 0, 0);
        
        const imgData = ctx.getImageData(0, 0, tc.width, tc.height);
        for (let i = 0; i < imgData.data.length; i += 4) {
            const px = i / 4; const x = px % tc.width; const y = Math.floor(px / tc.width);
            const mX = isVideo ? (tc.width - 1 - x) : x;
            if (!seg.data[y * tc.width + mX]) imgData.data[i + 3] = 0;
            else if ([1, -1, tc.width, -tc.width].some(n => !seg.data[y * tc.width + mX + n])) imgData.data[i+3] = 180;
        }
        ctx.putImageData(imgData, 0, 0);
        return tc;
    };

    const draw = useCallback((aiCanvas = null) => {
        const canvas = canvasRef.current; if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = bgColor; ctx.fillRect(0, 0, 350, 450);
        const activeImg = aiCanvas || image;
        if (activeImg) {
            ctx.save(); ctx.translate(175 + p.x, 225 + p.y); ctx.scale(p.s, p.s);
            ctx.drawImage(activeImg, -activeImg.width / 2, -activeImg.height / 2); ctx.restore();
        }
        if (suit.id) {
            const src = getClothesPath(suit.id);
            if (suitImg.current.src !== src) suitImg.current.src = src;
            if (suitImg.current.complete) {
                ctx.save(); ctx.translate(suit.x, suit.y); ctx.scale(suit.s * 1.5, suit.s * 1.5);
                ctx.drawImage(suitImg.current, -suitImg.current.width / 2, -suitImg.current.height / 2); ctx.restore();
            }
        }
    }, [image, p, suit, bgColor]);

    useEffect(() => {
        let raf;
        const loop = async () => {
            if (isCam && videoRef.current) {
                const aiCanvas = await processFrame(videoRef.current, true);
                draw(aiCanvas); raf = requestAnimationFrame(loop);
            }
        };
        if (isCam) raf = requestAnimationFrame(loop); else draw();
        return () => cancelAnimationFrame(raf);
    }, [isCam, bgColor, p, suit, autoAlign]);

    const download = () => {
        const pc = document.createElement('canvas'); const ctx = pc.getContext('2d');
        pc.width = 1800; pc.height = 1200; ctx.fillStyle = "white"; ctx.fillRect(0, 0, 1800, 1200);
        const drawGrid = (cols, rows, w, h, startX, startY, gX, gY) => {
            for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) ctx.drawImage(canvasRef.current, 0, 0, 350, 450, startX + c * (w + gX), startY + r * (h + gY), w, h);
        };
        if (mode === 'MIXED') { drawGrid(4,1,413,531,80,80,15,0); drawGrid(5,1,331,449,80,650,10,0); }
        else if (mode === 'TWO') drawGrid(4,2,413,531,80,80,20,30);
        else drawGrid(5,2,331,449,80,100,15,30);
        const a = document.createElement('a'); a.download = `EzID_Result.png`; a.href = pc.toDataURL(); a.click();
    };

    return (
        <div className="max-w-6xl mx-auto flex flex-col lg:flex-row gap-8">
            {/* é è¦½èˆ‡ç•«å¸ƒå€ */}
            <div className="w-full lg:w-[450px] flex flex-col items-center">
                <div 
                    className="relative w-full aspect-[35/45] bg-white rounded-[40px] overflow-hidden shadow-2xl border-[12px] border-white select-none"
                    onTouchStart={handleDown}
                    onTouchMove={handleMove}
                    onTouchEnd={handleUp}
                    onMouseDown={handleDown}
                    onMouseMove={handleMove}
                    onMouseUp={handleUp}
                    onMouseLeave={handleUp}
                >
                    {isCam && <video ref={videoRef} autoPlay playsInline className="absolute inset-0 w-full h-full object-cover opacity-0" />}
                    <canvas ref={canvasRef} width={350} height={450} className="w-full h-full" />
                    <div className="guide-overlay"></div>
                    
                    <div className="absolute top-5 right-5 flex flex-col gap-4 bg-white/50 p-2 rounded-full backdrop-blur-md">
                        {['white','#007bff','#ff0000'].map(c => (
                            <div key={c} onClick={()=>setBgColor(c)} className={`bg-dot ${bgColor===c?'active':''}`} style={{backgroundColor:c}}></div>
                        ))}
                    </div>
                    {isProcessing && <div className="absolute inset-0 bg-slate-900/40 backdrop-blur-md flex items-center justify-center text-white font-black">AI LOADING...</div>}
                </div>

                <div className="w-full mt-6 grid grid-cols-2 gap-4 px-2">
                    {isCam ? (
                        <button onClick={() => {
                            const tc = document.createElement('canvas'); tc.width = 350; tc.height = 450;
                            tc.getContext('2d').drawImage(canvasRef.current, 0, 0);
                            const img = new Image(); img.onload = () => { setImage(img); setIsCam(false); };
                            img.src = tc.toDataURL();
                        }} className="col-span-2 bg-red-500 text-white py-4 rounded-3xl font-black shadow-xl active:scale-95 transition">ğŸ“¸ æ‹æ”å­˜æª”</button>
                    ) : (
                        <>
                            <button onClick={() => { setIsCam(true); navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } }).then(s => videoRef.current.srcObject = s); }} className="bg-slate-900 text-white py-4 rounded-3xl font-black active:scale-95 transition">ğŸ“· é–‹å•Ÿç›¸æ©Ÿ</button>
                            <label className="bg-white border-2 border-slate-900 py-4 rounded-3xl font-black text-center cursor-pointer active:scale-95 transition">ğŸ“ ä¸Šå‚³æª”æ¡ˆ <input type="file" className="hidden" onChange={async (e)=>{
                                const file = e.target.files[0]; if(!file) return;
                                const img = new Image(); img.onload = async () => {
                                    const ai = await processFrame(img, false);
                                    const f = new Image(); f.onload = () => setImage(f);
                                    f.src = ai.toDataURL();
                                };
                                img.src = URL.createObjectURL(file);
                            }} accept="image/*" /></label>
                        </>
                    )}
                </div>
            </div>

            {/* æ§åˆ¶é¢æ¿å€ */}
            <div className="flex-1 space-y-6">
                <div className="bg-white p-6 md:p-8 rounded-[40px] border border-slate-100 shadow-sm space-y-8">
                    <div className="flex justify-between items-center">
                        <h1 className="text-2xl font-black text-slate-800">EzID <span className="text-blue-600">Pro</span></h1>
                        <label className="flex items-center gap-3 cursor-pointer bg-slate-100 px-4 py-2 rounded-full">
                            <span className="text-xs font-bold text-slate-500 uppercase">AI è‡ªå‹•å°é½Š</span>
                            <input type="checkbox" checked={autoAlign} onChange={e=>setAutoAlign(e.target.checked)} className="accent-blue-600 w-5 h-5" />
                        </label>
                    </div>

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                        {/* äººåƒèª¿æ•´ */}
                        <section className={`space-y-4 ${autoAlign ? 'opacity-30 pointer-events-none' : ''}`}>
                            <h3 className="text-xs font-black text-slate-400 uppercase tracking-widest">1. äººåƒæ‰‹å‹•å¾®èª¿</h3>
                            <div className="space-y-4">
                                <div className="flex items-center gap-4 text-xs font-bold"><span>ç¸®æ”¾</span><input type="range" min="0.3" max="1.5" step="0.01" value={p.s} onChange={e=>setP({...p,s:parseFloat(e.target.value)})} className="flex-1 accent-slate-900"/></div>
                                <div className="flex items-center gap-4 text-xs font-bold"><span>æ°´å¹³</span><input type="range" min="-150" max="150" value={p.x} onChange={e=>setP({...p,x:parseInt(e.target.value)})} className="flex-1 accent-slate-900"/></div>
                                <div className="flex items-center gap-4 text-xs font-bold"><span>å‚ç›´</span><input type="range" min="-150" max="150" value={p.y} onChange={e=>setP({...p,y:parseInt(e.target.value)})} className="flex-1 accent-slate-900"/></div>
                            </div>
                        </section>

                        {/* è¡£æœèª¿æ•´ */}
                        <section className="space-y-4">
                            <h3 className="text-xs font-black text-blue-500 uppercase tracking-widest">2. è¡£æœå¤§å°èˆ‡æ¨£å¼</h3>
                            <div className="space-y-4">
                                <div className="flex items-center gap-4 text-xs font-bold text-blue-600"><span>å¤§å°</span><input type="range" min="0.1" max="0.8" step="0.01" value={suit.s} onChange={e=>setSuit({...suit,s:parseFloat(e.target.value)})} className="flex-1 accent-blue-600"/></div>
                                <p className="text-[10px] text-slate-400">â€» æç¤ºï¼šè«‹ç›´æ¥åœ¨å·¦å´ç…§ç‰‡ä¸ŠæŒ‰ä½æ‹–æ›³ä¾†ç§»å‹•è¡£æœä½ç½®</p>
                                <div className="flex gap-3 overflow-x-auto pb-2 no-scrollbar">
                                    {['m1','m2','m3','m4','m5'].map(n=>(
                                        <div key={n} onClick={()=>setSuit({...suit,id:n})} className={`p-1 rounded-2xl border-2 shrink-0 cursor-pointer transition-all ${suit.id===n?'border-blue-600 bg-blue-50 scale-105':'border-transparent opacity-40 hover:opacity-100'}`}>
                                            <img src={getClothesPath(n)} className="w-16 h-16 object-contain" />
                                        </div>
                                    ))}
                                    <button onClick={()=>setSuit({...suit,id:null})} className="px-5 border-2 border-dashed rounded-2xl text-slate-300 hover:text-red-400 hover:border-red-400 transition">æ¸…ç©º</button>
                                </div>
                            </div>
                        </section>
                    </div>
                    
                    <hr className="border-slate-100" />

                    <div className="flex flex-col md:flex-row gap-6 items-center">
                        <div className="flex-1 w-full space-y-4">
                            <h3 className="text-xs font-black text-slate-400 uppercase tracking-widest">3. åˆ—å°è¦æ ¼</h3>
                            <div className="flex gap-2 p-1 bg-slate-100 rounded-2xl">
                                {[['MIXED','1+2å‹æ··åˆ'],['TWO','ç´” 2 å‹'],['ONE','ç´” 1 å‹']].map(([k,v])=>(
                                    <button key={k} onClick={()=>setMode(k)} className={`flex-1 py-3 rounded-xl font-bold text-xs transition ${mode===k?'bg-white text-slate-900 shadow-sm':'text-slate-500'}`}>{v}</button>
                                ))}
                            </div>
                        </div>
                        <button onClick={download} className="w-full md:w-auto px-12 bg-slate-900 text-white py-6 rounded-[32px] font-black text-lg shadow-2xl hover:bg-blue-600 transition active:scale-95">ğŸ’¾ å„²å­˜ 4x6 å‹æª”æ¡ˆ</button>
                    </div>
                </div>
            </div>
        </div>
    );
};

ReactDOM.createRoot(document.getElementById('root')).render(<EzIDApp />);
</script>
</body>
</html>
