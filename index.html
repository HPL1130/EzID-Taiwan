<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>EzID Taiwan v1.7.5 - é‚è¼¯æ‹†è§£ç‰ˆ</title>
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0/dist/body-pix.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
<style>
    body { background-color: #f1f5f9; color: #1e293b; font-family: system-ui, sans-serif; -webkit-tap-highlight-color: transparent; }
    .canvas-container { position: relative; touch-action: none; background: #e2e8f0; border-radius: 24px; overflow: hidden; border: 4px solid #fff; box-shadow: 0 10px 30px -5px rgba(0,0,0,0.1); }
    canvas { width: 100%; height: auto; display: block; background: white; }
    .id-guide { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -55%); width: 62%; height: 62%; border: 2px dashed rgba(239, 68, 68, 0.4); border-radius: 50%; pointer-events: none; z-index: 10; }
    input[type=range] { -webkit-appearance: none; width: 100%; height: 8px; background: #cbd5e1; border-radius: 4px; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%; background: #0f172a; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    .bg-dot { width: 34px; height: 34px; border-radius: 50%; cursor: pointer; border: 3px solid white; box-shadow: 0 0 0 1px #cbd5e1; transition: 0.2s; }
    .bg-dot.active { transform: scale(1.1); box-shadow: 0 0 0 3px #3b82f6; }
</style>
</head>
<body class="p-3 md:p-8">
<div id="root"></div>

<script type="text/babel">
const { useState, useRef, useEffect, useCallback } = React;

const EzIDApp = () => {
    const [image, setImage] = useState(null);
    const [isCam, setIsCam] = useState(false);
    const [mode, setMode] = useState('MIXED');
    const [bgColor, setBgColor] = useState('white');
    const [p, setP] = useState({ x: 0, y: 0, s: 0.7 });
    const [suit, setSuit] = useState({ id: null, x: 175, y: 340, s: 0.35 });
    const [isProcessing, setIsProcessing] = useState(false);
    
    const canvasRef = useRef(null);
    const videoRef = useRef(null);
    const suitImg = useRef(new Image());
    const isDragging = useRef(false);
    const lastPos = useRef({ x: 0, y: 0 });
    const lastDist = useRef(0);

    const getClothesPath = (id) => id ? `${window.location.href.split('?')[0].replace(/\/[^\/]*$/, '')}/clothes/suit-${id}.png` : "";

    // ã€æ ¸å¿ƒä¿®å¾©ã€‘ç¨ç«‹è‡ªå‹•å°é½Šï¼šåƒ…èª¿æ•´åº§æ¨™ï¼Œä¸æ”¹è®Šåœ–ç‰‡åƒç´ 
    const runAutoAlign = async () => {
        if (!image || !window.faceModel) return;
        setIsProcessing(true);
        try {
            const preds = await window.faceModel.estimateFaces(image, false);
            if (preds.length > 0) {
                const face = preds[0];
                const [x1, y1] = face.topLeft;
                const [x2, y2] = face.bottomRight;
                const faceCX = (x1 + x2) / 2;
                const faceCY = (y1 + y2) / 2;
                const faceH = (y2 - y1);
                
                // å°ç£è­‰ä»¶ç…§æ¨™æº–ï¼šé ­åƒä½”æ¯”ç´„ 70%-80%ï¼Œé ­é ‚è‡³ç•«é¢ä¸Šæ–¹éœ€ç•™ç™½
                const targetFaceH = 350 * 0.45; 
                const scale = targetFaceH / faceH;
                
                setP({
                    s: scale,
                    x: (image.width/2 - faceCX) * scale,
                    y: (image.height*0.42 - faceCY) * scale
                });
            } else {
                alert("æœªåµæ¸¬åˆ°äººè‡‰ï¼Œè«‹æ‰‹å‹•èª¿æ•´ã€‚");
            }
        } catch (e) { console.error(e); }
        setIsProcessing(false);
    };

    // ç¨ç«‹å»èƒŒï¼šåƒ…åœ¨ä½¿ç”¨è€…é»æ“Šæ™‚æ‰åŸ·è¡Œ
    const runAIBGRemove = async () => {
        if (!image || !window.bodyPixModel) return;
        setIsProcessing(true);
        const seg = await window.bodyPixModel.segmentPerson(image, { internalResolution: 'low', segmentationThreshold: 0.7 });
        const tc = document.createElement('canvas'); 
        tc.width = image.width; tc.height = image.height;
        const ctx = tc.getContext('2d');
        ctx.drawImage(image, 0, 0);
        
        const imgData = ctx.getImageData(0, 0, tc.width, tc.height);
        for (let i = 0; i < imgData.data.length; i += 4) {
            const idx = (i/4);
            if (!seg.data[idx]) {
                imgData.data[i + 3] = 0;
            } else {
                // è¼•å¾®ç¾½åŒ–
                let isEdge = !seg.data[idx-1] || !seg.data[idx+1] || !seg.data[idx-tc.width] || !seg.data[idx+tc.width];
                if(isEdge) imgData.data[i+3] = 180;
            }
        }
        ctx.putImageData(imgData, 0, 0);
        const finalImg = new Image();
        finalImg.onload = () => { setImage(finalImg); setIsProcessing(false); };
        finalImg.src = tc.toDataURL();
    };

    const draw = useCallback(() => {
        const canvas = canvasRef.current; if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = bgColor; ctx.fillRect(0, 0, 350, 450);
        if (image) {
            ctx.save(); ctx.translate(175 + p.x, 225 + p.y); ctx.scale(p.s, p.s);
            ctx.drawImage(image, -image.width / 2, -image.height / 2); ctx.restore();
        }
        if (suit.id) {
            const src = getClothesPath(suit.id);
            if (suitImg.current.src !== src) suitImg.current.src = src;
            if (suitImg.current.complete) {
                ctx.save(); ctx.translate(suit.x, suit.y); ctx.scale(suit.s * 1.5, suit.s * 1.5);
                ctx.drawImage(suitImg.current, -suitImg.current.width / 2, -suitImg.current.height / 2); ctx.restore();
            }
        }
    }, [image, p, suit, bgColor]);

    useEffect(() => { draw(); }, [draw]);
    useEffect(() => {
        const init = async () => {
            window.bodyPixModel = await bodyPix.load({ architecture: 'MobileNetV1', outputStride: 16, multiplier: 0.75 });
            window.faceModel = await blazeface.load();
        };
        init();
    }, []);

    return (
        <div className="max-w-6xl mx-auto flex flex-col lg:flex-row gap-8 pb-32">
            <div className="w-full lg:w-[450px] flex flex-col items-center">
                <div 
                    className="canvas-container w-full aspect-[35/45] select-none"
                    onTouchStart={(e)=>{
                        if(!suit.id) return;
                        if(e.touches.length===2) lastDist.current=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                        else { isDragging.current=true; lastPos.current={x:e.touches[0].clientX, y:e.touches[0].clientY}; }
                    }}
                    onTouchMove={(e)=>{
                        if(!suit.id) return; if(e.cancelable) e.preventDefault();
                        if(e.touches.length===2){
                            const dist=Math.hypot(e.touches[0].clientX-e.touches[1].clientX, e.touches[0].clientY-e.touches[1].clientY);
                            if(lastDist.current>0) setSuit(prev=>({...prev, s:Math.min(Math.max(prev.s*(dist/lastDist.current),0.1),0.9)}));
                            lastDist.current=dist;
                        } else if(isDragging.current){
                            const dx=e.touches[0].clientX-lastPos.current.x, dy=e.touches[0].clientY-lastPos.current.y;
                            const rect=canvasRef.current.getBoundingClientRect();
                            setSuit(prev=>({...prev, x:prev.x+dx*(350/rect.width), y:prev.y+dy*(450/rect.height)}));
                            lastPos.current={x:e.touches[0].clientX, y:e.touches[0].clientY};
                        }
                    }}
                    onTouchEnd={()=>{isDragging.current=false; lastDist.current=0;}}
                >
                    {isCam && <video ref={videoRef} autoPlay playsInline className="absolute inset-0 w-full h-full object-cover scale-x-[-1] z-20" />}
                    <canvas ref={canvasRef} width={350} height={450} />
                    <div className="id-guide"></div>
                    <div className="absolute top-5 right-5 flex flex-col gap-4 bg-white/50 p-2 rounded-full backdrop-blur-md z-30">
                        {['white','#007bff','#ff0000'].map(c => (
                            <div key={c} onClick={()=>setBgColor(c)} className={`bg-dot ${bgColor===c?'active':''}`} style={{backgroundColor:c}}></div>
                        ))}
                    </div>
                    {isProcessing && <div className="absolute inset-0 bg-white/60 flex items-center justify-center font-black text-blue-600 z-40">AI WORKING...</div>}
                </div>

                <div className="w-full mt-6 grid grid-cols-2 gap-3">
                    <button onClick={()=>{
                        if(isCam){
                            const v=videoRef.current, c=document.createElement('canvas');
                            c.width=v.videoWidth; c.height=v.videoHeight;
                            const ctx=c.getContext('2d'); ctx.translate(c.width,0); ctx.scale(-1,1); ctx.drawImage(v,0,0);
                            const img=new Image(); img.onload=()=>setImage(img); img.src=c.toDataURL('image/jpeg',0.9);
                            setIsCam(false);
                        } else {
                            setIsCam(true); navigator.mediaDevices.getUserMedia({video:{facingMode:'user'}}).then(s=>videoRef.current.srcObject=s);
                        }
                    }} className="bg-slate-900 text-white py-4 rounded-2xl font-black">{isCam?'ğŸ“¸ é»æ“Šæ‹ç…§':'ğŸ“· ç›¸æ©Ÿæ‹ç…§'}</button>
                    
                    <label className="bg-white border-2 border-slate-900 py-4 rounded-2xl font-black text-center cursor-pointer">ä¸Šå‚³æª”æ¡ˆ<input type="file" className="hidden" onChange={(e)=>{
                        const file=e.target.files[0]; if(!file) return;
                        const img=new Image(); img.onload=()=>setImage(img); img.src=URL.createObjectURL(file);
                    }} accept="image/*"/></label>

                    <button onClick={runAutoAlign} className="bg-blue-600 text-white py-4 rounded-2xl font-black text-sm shadow-lg shadow-blue-200">ğŸ¯ AI è‡ªå‹•å°é½Šäººåƒ</button>
                    <button onClick={runAIBGRemove} className="bg-white border-2 border-blue-600 text-blue-600 py-4 rounded-2xl font-black text-sm">âœ¨ åŸ·è¡Œ AI å»èƒŒ (é¸ç”¨)</button>
                </div>
            </div>

            <div className="flex-1 space-y-6">
                <div className="bg-white p-6 md:p-8 rounded-[40px] shadow-sm border border-slate-200 space-y-8">
                    <h2 className="text-xl font-black border-b pb-4">æ§åˆ¶é¢æ¿ <span className="text-slate-400 text-xs ml-2">v1.7.5</span></h2>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <section className="space-y-6">
                            <h3 className="text-[10px] font-black text-slate-400 uppercase tracking-tighter">äººåƒå¾®èª¿</h3>
                            <div className="space-y-6 px-1">
                                <div className="space-y-2">
                                    <div className="flex justify-between text-xs font-bold"><span>å¤§å°</span><span>{(p.s*100).toFixed(0)}%</span></div>
                                    <input type="range" min="0.3" max="1.5" step="0.01" value={p.s} onChange={e=>setP({...p,s:parseFloat(e.target.value)})} />
                                </div>
                                <div className="space-y-2">
                                    <div className="flex justify-between text-xs font-bold"><span>ä¸Šä¸‹ä½ç½®</span><span>{p.y.toFixed(0)}</span></div>
                                    <input type="range" min="-200" max="200" value={p.y} onChange={e=>setP({...p,y:parseInt(e.target.value)})} />
                                </div>
                            </div>
                        </section>

                        <section className="space-y-4">
                            <h3 className="text-[10px] font-black text-blue-500 uppercase tracking-tighter">æœè£æ›¿æ› (æ”¯æ´å…©æŒ‡ç¸®æ”¾)</h3>
                            <div className="flex gap-3 overflow-x-auto pb-2 no-scrollbar">
                                {['m1','m2','m3','m4','m5'].map(n=>(
                                    <div key={n} onClick={()=>setSuit({...suit, id:n})} className={`p-2 rounded-xl border-2 shrink-0 ${suit.id===n?'border-blue-600 bg-blue-50':'border-slate-50'}`}>
                                        <img src={getClothesPath(n)} className="w-12 h-12 object-contain" />
                                    </div>
                                ))}
                                <button onClick={()=>setSuit({...suit, id:null})} className="px-4 border-2 border-dashed border-red-100 text-red-500 font-bold text-[10px] rounded-xl shrink-0">æ¸…é™¤</button>
                            </div>
                        </section>
                    </div>

                    <div className="pt-6 border-t flex flex-col gap-4">
                        <div className="flex gap-2 p-1 bg-slate-100 rounded-2xl">
                            {[['MIXED','1+2å‹æ··åˆ'],['TWO','ç´” 2 å‹'],['ONE','ç´” 1 å‹']].map(([k,v])=>(
                                <button key={k} onClick={()=>setMode(k)} className={`flex-1 py-3 rounded-xl font-black text-[10px] transition ${mode===k?'bg-white shadow-sm':'text-slate-400'}`}>{v}</button>
                            ))}
                        </div>
                        <button onClick={()=>{
                            const pc=document.createElement('canvas'); const ctx=pc.getContext('2d');
                            pc.width=1800; pc.height=1200; ctx.fillStyle="white"; ctx.fillRect(0,0,1800,1200);
                            const drawGrid=(cols,rows,w,h,sX,sY,gX,gY)=>{
                                for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
                                    const x=sX+c*(w+gX), y=sY+r*(h+gY);
                                    ctx.drawImage(canvasRef.current,0,0,350,450,x,y,w,h);
                                    ctx.strokeStyle="#e2e8f0"; ctx.lineWidth=1; ctx.strokeRect(x,y,w,h);
                                }
                            };
                            if(mode==='MIXED'){ drawGrid(4,1,413,531,80,80,15,0); drawGrid(5,1,331,449,80,650,10,0); }
                            else if(mode==='TWO') drawGrid(4,2,413,531,80,80,20,30);
                            else drawGrid(5,2,331,449,80,100,15,30);
                            const a=document.createElement('a'); a.download=`EzID_Output.png`; a.href=pc.toDataURL(); a.click();
                        }} className="w-full bg-blue-600 text-white py-5 rounded-3xl font-black text-lg shadow-xl active:scale-95 transition-all">ğŸ’¾ ä¸‹è¼‰æ’ç‰ˆæª”æ¡ˆ (4x6 å‹)</button>
                    </div>
                </div>
            </div>
        </div>
    );
};

ReactDOM.createRoot(document.getElementById('root')).render(<EzIDApp />);
</script>
</body>
</html>
