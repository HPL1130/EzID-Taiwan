<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EzID v20.0 æ——è‰¦ç”Ÿç”¢åŠ›ç‰ˆ</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .canvas-shadow { box-shadow: 0 20px 50px -12px rgba(0,0,0,0.3); }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .loading-shimmer {
            background: linear-gradient(90deg, #f3f4f6 25%, #e5e7eb 50%, #f3f4f6 75%);
            background-size: 200% 100%; animation: shimmer 1.5s infinite;
        }
        @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
    </style>
</head>
<body class="bg-[#f0f2f5] min-h-screen pb-20">
    <div id="root"></div>

<script type="text/babel">
const { useState, useRef, useEffect, useCallback, useTransition } = React;

const PRINT_SPECS = {
    'A4-20': { w: 2480, h: 3508, photos: 20, grid: [5, 4], size: [413, 531], name: 'A4 - 2å‹ (20å¼µ)' },
    'A4-42': { w: 2480, h: 3508, photos: 42, grid: [7, 6], size: [295, 413], name: 'A4 - 1å‹ (42å¼µ)' },
    '4x6-8':  { w: 1800, h: 1200, photos: 8,  grid: [2, 4], size: [413, 531], name: '4x6 - 2å‹ (8å¼µ)' },
    '4x6-10': { w: 1800, h: 1200, photos: 10, grid: [2, 5], size: [295, 413], name: '4x6 - 1å‹ (10å¼µ)' }
};

function App() {
    const [isPending, startTransition] = useTransition();
    const [image, setImage] = useState(null);
    const [transform, setTransform] = useState({ x: 0, y: -20, s: 0.45, r: 0 });
    const [slots, setSlots] = useState([]);
    const [progress, setProgress] = useState(0);
    const [preview, setPreview] = useState(null);
    
    const canvasRef = useRef(null);
    const dragRef = useRef({ active: false, x: 0, y: 0 });

    // âœ… é«˜æ¸…ç”Ÿç”¢è»Œé‡ç¹ªé‚è¼¯ (The Dual-Track Engine)
    const drawHighResItem = (ctx, img, slotState, x, y, pw, ph) => {
        ctx.save();
        const { x: tx, y: ty, s, r } = slotState;
        // è¨ˆç®—ç·¨è¼¯å™¨(350pxå¯¬)èˆ‡å¯¦éš›åˆ—å°å°ºå¯¸çš„ç¸®æ”¾æ¯”
        const ratio = pw / 350; 
        
        ctx.translate(x + pw / 2, y + ph / 2);
        ctx.rotate(r * Math.PI / 180);
        // æ ¸å¿ƒä¿®æ­£ï¼šs * ratio ç¢ºä¿ç¸®æ”¾æ¯”ä¾‹åœ¨ä¸åŒè§£æåº¦ä¸‹ä¿æŒçµ•å°ç²¾ç¢º
        ctx.scale(s * ratio, s * ratio);
        ctx.drawImage(img, -img.width / 2 + (tx / s), -img.height / 2 + (ty / s));
        ctx.restore();
    };

    // âœ… éåŒæ­¥ç”Ÿç”¢å¼•æ“ (Async Production Engine)
    const handleExport = (specKey) => {
        if (!image) return alert("è«‹å…ˆä¸Šå‚³ç…§ç‰‡");
        const spec = PRINT_SPECS[specKey];
        
        startTransition(async () => {
            const canvas = document.createElement('canvas');
            canvas.width = spec.w; canvas.height = spec.h;
            const ctx = canvas.getContext('2d', { alpha: false });
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, spec.w, spec.h);

            const [rows, cols] = spec.grid;
            const [pw, ph] = spec.size;
            const marginX = (spec.w - cols * pw) / (cols + 1);
            const marginY = (spec.h - rows * ph) / (rows + 1);

            for (let i = 0; i < spec.photos; i++) {
                const row = Math.floor(i / cols);
                const col = i % cols;
                const x = marginX + col * (pw + marginX);
                const y = marginY + row * (ph + marginY);
                
                // ä½¿ç”¨ç›®å‰ç‹€æ…‹æˆ–æ§½ä½ç‹€æ…‹é€²è¡Œã€Œé«˜æ¸…é‡ç¹ªã€
                const targetState = slots[i]?.state || transform;
                drawHighResItem(ctx, image, targetState, x, y, pw, ph);
                
                // ç•«åˆ‡ç·šé‚Šæ¡†
                ctx.strokeStyle = "#dddddd";
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, pw, ph);

                setProgress(Math.round(((i + 1) / spec.photos) * 100));
                // é‡‹æ”¾ä¸»åŸ·è¡Œç·’ï¼Œé˜²æ­¢ UI å‡çµ
                await new Promise(r => requestAnimationFrame(r));
            }
            
            setPreview(canvas.toDataURL('image/jpeg', 0.95));
            setProgress(0);
        });
    };

    // ğŸ¨ å³æ™‚ç·¨è¼¯æ¸²æŸ“
    useEffect(() => {
        const ctx = canvasRef.current?.getContext('2d');
        if (!ctx || !image) return;
        ctx.clearRect(0, 0, 350, 450);
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, 350, 450);
        
        ctx.save();
        ctx.translate(175 + transform.x, 225 + transform.y);
        ctx.rotate(transform.r * Math.PI / 180);
        ctx.scale(transform.s, transform.s);
        ctx.drawImage(image, -image.width / 2, -image.height / 2);
        ctx.restore();
    }, [image, transform]);

    return (
        <div className="max-w-md mx-auto p-4 space-y-6">
            <header className="text-center pt-6">
                <h1 className="text-3xl font-black text-slate-800 tracking-tight">EzID <span className="text-blue-600">v20.0</span></h1>
                <p className="text-slate-500 font-medium">æ——è‰¦ç”Ÿç”¢åŠ›ç‰ˆ â€¢ é«˜æ¸…ç„¡æè¼¸å‡º</p>
            </header>

            {/* ä¸»ç·¨è¼¯å€ */}
            <div className="canvas-container relative flex justify-center">
                <canvas 
                    ref={canvasRef} width="350" height="450" 
                    className="canvas-shadow rounded-[2rem] bg-white touch-none"
                    onPointerDown={e => {
                        e.target.setPointerCapture(e.pointerId);
                        dragRef.current = { active: true, x: e.clientX, y: e.clientY };
                    }}
                    onPointerMove={e => {
                        if (!dragRef.current.active) return;
                        const dx = e.clientX - dragRef.current.x;
                        const dy = e.clientY - dragRef.current.y;
                        setTransform(t => ({ ...t, x: t.x + dx, y: t.y + dy }));
                        dragRef.current.x = e.clientX;
                        dragRef.current.y = e.clientY;
                    }}
                    onPointerUp={() => dragRef.current.active = false}
                />
            </div>

            {/* æ§åˆ¶å° */}
            <section className="bg-white rounded-3xl p-6 shadow-sm space-y-4">
                <div className="space-y-2">
                    <div className="flex justify-between text-sm font-bold text-slate-600">
                        <span>ç¸®æ”¾å€ç‡</span>
                        <span>{transform.s.toFixed(2)}x</span>
                    </div>
                    <input type="range" min="0.1" max="1.5" step="0.01" value={transform.s} 
                        onChange={e => setTransform(t => ({ ...t, s: parseFloat(e.target.value) }))}
                        className="w-full h-2 bg-slate-100 rounded-lg appearance-none accent-blue-600" />
                </div>
                <div className="space-y-2">
                    <div className="flex justify-between text-sm font-bold text-slate-600">
                        <span>æ—‹è½‰è§’åº¦</span>
                        <span>{transform.r}Â°</span>
                    </div>
                    <input type="range" min="-180" max="180" step="1" value={transform.r} 
                        onChange={e => setTransform(t => ({ ...t, r: parseInt(e.target.value) }))}
                        className="w-full h-2 bg-slate-100 rounded-lg appearance-none accent-indigo-600" />
                </div>
            </section>

            {/* åŠŸèƒ½æŒ‰éˆ• */}
            <div className="grid grid-cols-2 gap-4">
                <label className="flex items-center justify-center bg-slate-900 text-white h-20 rounded-3xl font-bold cursor-pointer hover:bg-black transition-colors">
                    ä¸Šå‚³åŸå§‹æª”
                    <input type="file" hidden onChange={e => {
                        const file = e.target.files[0];
                        if (file) {
                            const url = URL.createObjectURL(file);
                            const img = new Image();
                            img.onload = () => { setImage(img); URL.revokeObjectURL(url); };
                            img.src = url;
                        }
                    }} />
                </label>
                <button 
                    onClick={() => setSlots([{ state: { ...transform } }, ...slots.slice(0, 41)])}
                    className="bg-blue-600 text-white h-20 rounded-3xl font-bold hover:bg-blue-700 transition-colors shadow-lg shadow-blue-200">
                    æš«å­˜ç›®å‰ä½ç½®
                </button>
            </div>

            {/* æ’ç‰ˆå°å‡ºå€ */}
            <section className="bg-white rounded-3xl p-6 shadow-sm">
                <h3 className="text-slate-800 font-extrabold mb-4 flex items-center">
                    <span className="w-2 h-6 bg-blue-600 rounded-full mr-2"></span>
                    å°ˆæ¥­æ’ç‰ˆè¼¸å‡º (300dpi)
                </h3>
                
                {isPending && (
                    <div className="mb-4">
                        <div className="flex justify-between text-xs mb-1 font-bold text-blue-600">
                            <span>é«˜æ¸…å¼•æ“æ¸²æŸ“ä¸­...</span>
                            <span>{progress}%</span>
                        </div>
                        <div className="w-full bg-slate-100 h-2 rounded-full overflow-hidden">
                            <div className="bg-blue-600 h-full transition-all duration-300" style={{ width: `${progress}%` }}></div>
                        </div>
                    </div>
                )}

                <div className="grid grid-cols-1 gap-2">
                    {Object.entries(PRINT_SPECS).map(([key, spec]) => (
                        <button 
                            key={key} 
                            disabled={isPending || !image}
                            onClick={() => handleExport(key)}
                            className="flex justify-between items-center px-4 h-14 bg-slate-50 border border-slate-100 rounded-2xl hover:bg-blue-50 hover:border-blue-200 transition-all group disabled:opacity-40">
                            <span className="font-bold text-slate-700 group-hover:text-blue-700">{spec.name}</span>
                            <span className="text-slate-400">â†’</span>
                        </button>
                    ))}
                </div>
            </section>

            {/* é è¦½èˆ‡ä¸‹è¼‰ */}
            {preview && (
                <div className="fixed inset-0 bg-slate-900/95 z-[100] flex flex-col p-6 animate-in fade-in duration-300">
                    <div className="flex-1 flex items-center justify-center overflow-hidden">
                        <img src={preview} className="max-w-full max-h-full shadow-2xl rounded-sm border-[12px] border-white" />
                    </div>
                    <div className="mt-6 flex gap-4">
                        <button onClick={() => setPreview(null)} className="flex-1 h-16 bg-slate-700 text-white rounded-2xl font-bold">é—œé–‰é è¦½</button>
                        <a href={preview} download="EzID_Print.jpg" className="flex-1 h-16 bg-emerald-600 text-white rounded-2xl font-bold flex items-center justify-center">ä¸‹è¼‰ JPG</a>
                    </div>
                </div>
            )}
        </div>
    );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
</script>
</body>
</html>
