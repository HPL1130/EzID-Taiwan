<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EzID v20.48.33</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: sans-serif; background: #020617; color: #f8fafc; margin: 0; overflow-x: hidden; }
        #root { width: 100%; max-width: 500px; margin: 0 auto; min-height: 100vh; padding: 15px; }
        .zone-box { background: rgba(30, 41, 59, 0.4); border-radius: 24px; border: 1px solid rgba(255,255,255,0.05); padding: 16px; margin-bottom: 12px; }
        .zone-tag { font-size: 10px; font-weight: 900; color: #3b82f6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
        .stage-box { position: relative; width: 100%; aspect-ratio: 350/466; background: #fff; border-radius: 16px; overflow: hidden; touch-action: none; margin: 0 auto; }
    </style>
</head>
<body>
    <div id="root"></div>

<script type="text/babel">
const { useState, useRef, useEffect, useMemo } = React;

// 1️⃣ [MODULE] EZ_SPEC_ENGINE (規格定義與 MIX 分區邏輯)
const SPECS = {
    'A4-20':   { id: 'A4-20',   w: 2480, h: 3508, grid: [5, 4], size: [413, 531], count: 20, name: 'A4-2吋(20張)' },
    'A4-42':   { id: 'A4-42',   w: 2480, h: 3508, grid: [7, 6], size: [295, 413], count: 42, name: 'A4-1吋(42張)' },
    'A4-MIX':  { id: 'A4-MIX',  w: 2480, h: 3508, name: 'A4-混合(30張)', sections: [{ y: 0, grid: [3, 4], size: [413, 531], count: 12, label: '2吋區' }, { y: 1754, grid: [3, 6], size: [295, 413], count: 18, label: '1吋區' }] },
    '4x6-8':   { id: '4x6-8',   w: 1800, h: 1200, grid: [2, 4], size: [413, 531], count: 8, name: '4x6-2吋(8張)' },
    '4x6-10':  { id: '4x6-10',  w: 1800, h: 1200, grid: [2, 5], size: [295, 413], count: 10, name: '4x6-1吋(10張)' },
    '4x6-MIX': { id: '4x6-MIX', w: 1800, h: 1200, name: '4x6-混合(9張)', sections: [{ y: 0, grid: [1, 4], size: [413, 531], count: 4, label: '2吋區' }, { y: 600, grid: [1, 5], size: [295, 413], count: 5, label: '1吋區' }] }
};

const FILL_ORDER_DESC = "圖層由左至右、由上至下填充，超出將循環使用。";

// 2️⃣ [MODULE] EZ_ASSET_LOADER (圖片資源載入與預處理)
const AssetLoader = {
    async load(file) {
        return new Promise((res) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => res({ img, src: e.target.result });
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }
};

// 3️⃣ [MODULE] EZ_SAFETY_GUARD (安全性檢查與邊界保護)
const SafetyGuard = {
    validateExport(specId, layers) {
        if (!SPECS[specId]) throw new Error("無效的規格 ID");
        if (layers.length === 0) throw new Error("人物池為空，無法輸出");
        return true;
    }
};

// 4️⃣ [MODULE] EZ_CORE_RENDERER (核心繪製、輔助圈與比例同步邏輯)
const CoreRenderer = {
    draw(ctx, layer, rect, hideGuides = false) {
        if (!ctx || !layer || !layer.img) return;
        ctx.save();
        ctx.fillStyle = "#fff"; ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
        ctx.beginPath(); ctx.rect(rect.x, rect.y, rect.w, rect.h); ctx.clip();
        const sc = rect.w / 600;
        ctx.translate(rect.x + rect.w/2 + layer.x * sc, rect.y + rect.h/2 + layer.y * sc);
        ctx.scale(layer.s * sc, layer.s * sc);
        ctx.drawImage(layer.img, -layer.img.width/2, -layer.img.height/2);
        ctx.restore();
        if (!hideGuides) {
            ctx.save();
            ctx.strokeStyle = "#3b82f6"; ctx.setLineDash([5, 5]); ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(rect.x + rect.w/2, rect.y + rect.h * 0.42, rect.w * 0.28, rect.h * 0.35, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    }
};

// 5️⃣ [MODULE] EZ_UI_STATE (React 狀態管理、圖層管理與形式)
function App() {
    const [ui, setUi] = useState({ spec: '4x6-MIX', results: null, mode: 'single' });
    const [scene, setScene] = useState({ layers: [], activeId: null });
    const canvasRef = useRef(null);
    const pointer = useRef({ x: 0, y: 0, dist: 0 });

    const bufferCanvas = useMemo(() => {
        const c = document.createElement('canvas'); c.width = 600; c.height = 800;
        return c;
    }, []);

    // Derived State: 語義提示文字
    const semanticText = useMemo(() => {
        const s = SPECS[ui.spec];
        const area = s.sections ? "混合分區" : "全版";
        return `${s.name} | ${area} | 預計輸出 ${s.count || (s.sections[0].count + s.sections[1].count)} 份`;
    }, [ui.spec]);

    useEffect(() => {
        const activeLayer = scene.layers.find(l => l.id === scene.activeId);
        const ctx = canvasRef.current?.getContext('2d');
        if (ctx) {
            ctx.clearRect(0, 0, 350, 466);
            if (activeLayer) CoreRenderer.draw(ctx, activeLayer, { x: 0, y: 0, w: 350, h: 466 });
        }
    }, [scene]);

    const handleFile = async (e) => {
        const f = e.target.files[0]; if (!f) return;
        const { img, src } = await AssetLoader.load(f);
        const sc = Math.max(600 / img.width, 800 / img.height) * 1.1;
        const newLayer = { id: Date.now(), x: 0, y: 0, s: sc, img, thumb: src };
        if (ui.mode === 'single') setScene({ layers: [newLayer], activeId: newLayer.id });
        else setScene(s => ({ layers: [...s.layers, newLayer], activeId: newLayer.id }));
        e.target.value = "";
    };

    // 6️⃣ [MODULE] EZ_EXPORT_MANAGER (核心修正：Mapping 快照與防禦邏輯)
    const handleExport = async (isAll) => {
        const targets = isAll ? Object.keys(SPECS) : [ui.spec];
        const resList = [];
        const validLayers = scene.layers.filter(l => l.img);
        
        try {
            SafetyGuard.validateExport(ui.spec, validLayers);
            
            console.group("[EzID Export Mapping]");
            console.log("導出時間:", new Date().toLocaleTimeString());
            console.log("使用圖層數:", validLayers.length);

            const bCtx = bufferCanvas.getContext('2d');
            const outCanvas = document.createElement('canvas');

            for (const sid of targets) {
                const s = SPECS[sid];
                outCanvas.width = s.w; outCanvas.height = s.h;
                const ctx = outCanvas.getContext('2d');
                ctx.fillStyle = "#fff"; ctx.fillRect(0, 0, s.w, s.h);
                
                let layerIndex = 0;
                const sections = s.sections || [{ y: 0, grid: s.grid, size: s.size, label: '全版' }];
                
                sections.forEach(sec => {
                    const areaH = s.sections ? (s.id === 'A4-MIX' ? 1754 : 600) : s.h;
                    const gapX = (s.w - (sec.grid[1] * sec.size[0])) / (sec.grid[1] + 1);
                    const gapY = (areaH - (sec.grid[0] * sec.size[1])) / (sec.grid[0] + 1);
                    
                    for (let r = 0; r < sec.grid[0]; r++) for (let c = 0; c < sec.grid[1]; c++) {
                        const currentLayer = validLayers[layerIndex % validLayers.length];
                        bCtx.clearRect(0, 0, 600, 800);
                        CoreRenderer.draw(bCtx, currentLayer, { x: 0, y: 0, w: 600, h: 800 }, true);
                        const px = gapX + c * (sec.size[0] + gapX);
                        const py = (sec.y || 0) + gapY + r * (sec.size[1] + gapY);
                        ctx.drawImage(bufferCanvas, 0, 0, 600, 800, px, py, sec.size[0], sec.size[1]);
                        layerIndex++;
                    }
                });
                console.log(`- ${s.name}: 完成映射 ${layerIndex} 個位置`);
                resList.push({ url: outCanvas.toDataURL('image/jpeg', 0.85), name: s.name, report: { layers: validLayers.length, slots: layerIndex } });
            }
            console.groupEnd();
            setUi(u => ({ ...u, results: resList }));
        } catch (err) {
            alert(err.message);
            console.groupEnd();
        }
    };

    return (
        <div className="flex flex-col gap-3 pb-24">
            <header className="flex justify-between items-center px-1">
                <h1 className="text-2xl font-black text-blue-500 italic">EzID</h1>
                <div className="flex bg-slate-800 p-1 rounded-lg gap-1">
                    <button onClick={() => { setUi(u => ({ ...u, mode: 'single' })); setScene({ layers: [], activeId: null }); }} className={`px-4 py-1.5 text-[10px] rounded-md ${ui.mode === 'single' ? 'bg-blue-600 shadow-lg' : 'text-slate-400'}`}>單人</button>
                    <button onClick={() => setUi(u => ({ ...u, mode: 'multi' }))} className={`px-4 py-1.5 text-[10px] rounded-md ${ui.mode === 'multi' ? 'bg-blue-600 shadow-lg' : 'text-slate-400'}`}>多人池</button>
                </div>
            </header>
            
            <div className="zone-box">
                <div className="zone-tag">❶ 選擇版面</div>
                <div className="grid grid-cols-2 gap-1 mb-3">{Object.values(SPECS).map(s => (<button key={s.id} onClick={() => setUi(u => ({ ...u, spec: s.id }))} className={`p-2 rounded-lg text-[10px] text-left pl-4 ${ui.spec === s.id ? 'bg-blue-600' : 'bg-slate-800 text-slate-400'}`}>{s.name}</button>))}</div>
                <div className="text-[10px] text-slate-400 bg-slate-900/50 p-2 rounded-lg border border-white/5 italic">語義：{semanticText}</div>
            </div>

            <div className="px-10"><div className="stage-box"
                onTouchMove={e => {
                    const t = e.touches;
                    if (t.length === 2) {
                        const d = Math.hypot(t[0].clientX - t[1].clientX, t[0].clientY - t[1].clientY);
                        const ratio = d / (pointer.current.dist || d); pointer.current.dist = d;
                        setScene(s => ({ ...s, layers: s.layers.map(l => l.id === s.activeId ? { ...l, s: l.s * ratio } : l) }));
                    } else {
                        const dx = (t[0].clientX - pointer.current.x) * (600 / 350);
                        const dy = (t[0].clientY - pointer.current.y) * (800 / 466);
                        pointer.current.x = t[0].clientX; pointer.current.y = t[0].clientY;
                        setScene(s => ({ ...s, layers: s.layers.map(l => l.id === s.activeId ? { ...l, x: l.x + dx, y: l.y + dy } : l) }));
                    }
                }}
                onTouchStart={e => {
                    if (e.touches.length === 2) pointer.current.dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    else { pointer.current.x = e.touches[0].clientX; pointer.current.y = e.touches[0].clientY; }
                }}
            ><canvas ref={canvasRef} width="350" height="466" className="w-full h-full" /></div></div>

            <div className="zone-box">
                <div className="zone-tag flex justify-between">❷ 人物圖層管理 <span className="text-[9px] text-slate-500 font-normal">{ui.mode==='multi' ? '多人模式' : '單人模式'}</span></div>
                <div className="text-[9px] text-blue-400 mb-2 opacity-70">順序規則：{FILL_ORDER_DESC}</div>
                <div className="flex gap-2 overflow-x-auto pb-1">
                    {scene.layers.map(l => (
                        <div key={l.id} className={`relative w-14 h-14 rounded-xl border-2 shrink-0 ${scene.activeId === l.id ? 'border-blue-500' : 'border-slate-700'}`}>
                            <img src={l.thumb} onClick={() => setScene(s => ({ ...s, activeId: l.id }))} className="w-full h-full object-cover rounded-lg" />
                            <button onClick={() => setScene(s => { const n = s.layers.filter(x => x.id !== l.id); return { layers: n, activeId: n[0]?.id } })} className="absolute -top-1.5 -right-1.5 bg-red-600 rounded-full w-4 h-4 text-[8px] flex items-center justify-center font-bold text-white shadow-lg">✕</button>
                        </div>
                    ))}
                    <label className="w-14 h-14 bg-slate-800 rounded-xl flex items-center justify-center text-xl shrink-0 cursor-pointer border-2 border-dashed border-slate-600">＋<input type="file" className="hidden" onChange={handleFile} /></label>
                </div>
            </div>

            <div className="grid grid-cols-2 gap-2">
                <button onClick={() => handleExport(false)} className="py-5 bg-blue-600 rounded-2xl font-black text-xs active:scale-95 transition-all">單規格輸出</button>
                <button onClick={() => handleExport(true)} className="py-5 bg-orange-600 rounded-2xl font-black text-xs active:scale-95 transition-all">全規格批次</button>
            </div>

            {ui.results && <div className="fixed inset-0 bg-slate-950 z-[999] overflow-y-auto p-4 flex flex-col gap-4">
                <div className="flex justify-between items-center px-1"><h2 className="text-xl font-black italic">檢核摘要</h2><button onClick={() => setUi(u => ({ ...u, results: null }))} className="text-slate-400 text-xs">返回畫布</button></div>
                {ui.results.map((r, i) => (
                    <div key={i} className="bg-slate-900 p-2 rounded-2xl border border-slate-800">
                        <div className="flex justify-between px-2 py-1 text-[10px] text-slate-400 uppercase tracking-tighter">
                            <span>✔ 圖層:{r.report.layers} 張</span>
                            <span>✔ 格子:{r.report.slots} 位</span>
                            <span>{r.report.layers < r.report.slots ? '⚠ 循環填充' : '✔ 完美覆蓋'}</span>
                        </div>
                        <img src={r.url} className="w-full rounded-xl mb-2"/>
                        <a href={r.url} download={`${r.name}.jpg`} className="block py-4 text-center bg-blue-500/10 text-blue-400 text-[10px] font-bold rounded-xl">DOWNLOAD {r.name}</a>
                    </div>
                ))}
                <div className="text-center py-4 text-[9px] text-slate-600 italic leading-relaxed">* 畫布僅供編輯比例預覽，最終解析度將依規格自動生成。</div>
                <div className="h-20"></div>
            </div>}
        </div>
    );
}
ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
