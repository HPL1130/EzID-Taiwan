<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>EzID Taiwan v1.7.1 - å…©æŒ‡ç¸®æ”¾ç‰ˆ</title>
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0/dist/body-pix.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
<style>
    body { background-color: #f8fafc; color: #1e293b; font-family: system-ui, sans-serif; -webkit-tap-highlight-color: transparent; overflow-x: hidden; }
    canvas { border-radius: 24px; max-width: 100%; height: auto; background: white; box-shadow: 0 20px 40px -10px rgba(0,0,0,0.15); border: 2px solid #fff; touch-action: none; cursor: move; }
    .bg-dot { width: 32px; height: 32px; border-radius: 50%; cursor: pointer; border: 3px solid white; box-shadow: 0 0 0 1px #cbd5e1; }
    .bg-dot.active { transform: scale(1.15); box-shadow: 0 0 0 2px #0f172a; }
</style>
</head>
<body class="p-3 md:p-8">
<div id="root"></div>

<script type="text/babel">
const { useState, useRef, useEffect, useCallback } = React;

const EzIDApp = () => {
    const [image, setImage] = useState(null);
    const [isCam, setIsCam] = useState(false);
    const [mode, setMode] = useState('MIXED');
    const [bgColor, setBgColor] = useState('white');
    const [p, setP] = useState({ x: 0, y: 0, s: 0.7 });
    const [suit, setSuit] = useState({ id: null, x: 175, y: 340, s: 0.35 });
    const [autoAlign, setAutoAlign] = useState(true);
    const [isProcessing, setIsProcessing] = useState(false);
    
    const canvasRef = useRef(null);
    const videoRef = useRef(null);
    const suitImg = useRef(new Image());
    const isDragging = useRef(false);
    const lastPos = useRef({ x: 0, y: 0 });
    const lastDist = useRef(0); // ç´€éŒ„å…©æŒ‡åˆå§‹è·é›¢

    const getClothesPath = (id) => {
        const url = window.location.href.split('?')[0];
        const baseUrl = url.endsWith('/') ? url : url.substring(0, url.lastIndexOf('/') + 1);
        return `${baseUrl}clothes/suit-${id}.png`;
    };

    // è§¸æ§é‚è¼¯å„ªåŒ–
    const handleTouchStart = (e) => {
        if (!suit.id) return;
        if (e.touches.length === 2) {
            // å…©æŒ‡æ¨¡å¼ï¼šè¨ˆç®—è·é›¢
            const dist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            lastDist.current = dist;
        } else if (e.touches.length === 1) {
            // å–®æŒ‡æ¨¡å¼ï¼šç§»å‹•
            isDragging.current = true;
            lastPos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
    };

    const handleTouchMove = (e) => {
        if (!suit.id) return;
        if (e.cancelable) e.preventDefault();

        if (e.touches.length === 2) {
            // é›™æŒ‡ç¸®æ”¾
            const dist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            if (lastDist.current > 0) {
                const ratio = dist / lastDist.current;
                setSuit(prev => ({
                    ...prev,
                    s: Math.min(Math.max(prev.s * ratio, 0.1), 0.9) // é™åˆ¶è¡£æœå¤§å°ç¯„åœ
                }));
            }
            lastDist.current = dist;
        } else if (e.touches.length === 1 && isDragging.current) {
            // å–®æŒ‡æ‹–æ›³
            const x = e.touches[0].clientX;
            const y = e.touches[0].clientY;
            const dx = x - lastPos.current.x;
            const dy = y - lastPos.current.y;
            const rect = canvasRef.current.getBoundingClientRect();
            setSuit(prev => ({ ...prev, x: prev.x + dx * (350/rect.width), y: prev.y + dy * (450/rect.height) }));
            lastPos.current = { x, y };
        }
    };

    const handleTouchEnd = () => {
        isDragging.current = false;
        lastDist.current = 0;
    };

    // é›»è…¦æ»‘é¼ ç›¸å®¹é‚è¼¯
    const handleMouseDown = (e) => {
        if (!suit.id) return;
        isDragging.current = true;
        lastPos.current = { x: e.clientX, y: e.clientY };
    };

    const handleMouseMove = (e) => {
        if (isDragging.current && suit.id) {
            const dx = e.clientX - lastPos.current.x;
            const dy = e.clientY - lastPos.current.y;
            const rect = canvasRef.current.getBoundingClientRect();
            setSuit(prev => ({ ...prev, x: prev.x + dx * (350/rect.width), y: prev.y + dy * (450/rect.height) }));
            lastPos.current = { x: e.clientX, y: e.clientY };
        }
    };

    // æ¨¡å‹èˆ‡ç¹ªåœ–é‚è¼¯ (æ‰¿è¥² v1.7.0)
    useEffect(() => {
        const init = async () => {
            setIsProcessing(true);
            try {
                window.bodyPixModel = await bodyPix.load({ architecture: 'MobileNetV1', outputStride: 16, multiplier: 0.75 });
                window.faceModel = await blazeface.load();
            } catch(e) {}
            setIsProcessing(false);
        };
        init();
    }, []);

    const draw = useCallback((aiCanvas = null) => {
        const canvas = canvasRef.current; if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = bgColor; ctx.fillRect(0, 0, 350, 450);
        const activeImg = aiCanvas || image;
        if (activeImg) {
            ctx.save(); ctx.translate(175 + p.x, 225 + p.y); ctx.scale(p.s, p.s);
            ctx.drawImage(activeImg, -activeImg.width / 2, -activeImg.height / 2); ctx.restore();
        }
        if (suit.id) {
            const src = getClothesPath(suit.id);
            if (suitImg.current.src !== src) suitImg.current.src = src;
            if (suitImg.current.complete) {
                ctx.save(); ctx.translate(suit.x, suit.y); ctx.scale(suit.s * 1.5, suit.s * 1.5);
                ctx.drawImage(suitImg.current, -suitImg.current.width / 2, -suitImg.current.height / 2); ctx.restore();
            }
        }
    }, [image, p, suit, bgColor]);

    useEffect(() => {
        let raf;
        const loop = async () => {
            if (isCam && videoRef.current) {
                const aiCanvas = await processFrame(videoRef.current, true);
                draw(aiCanvas);
                raf = requestAnimationFrame(loop);
            }
        };
        if (isCam) raf = requestAnimationFrame(loop); else draw();
        return () => cancelAnimationFrame(raf);
    }, [isCam, bgColor, p, suit, autoAlign, image]);

    const handleFileUpload = async (e) => {
        const file = e.target.files[0]; if (!file) return;
        setIsProcessing(true);
        const reader = new FileReader();
        reader.onload = (ev) => {
            const img = new Image();
            img.onload = async () => {
                setImage(img); // å…ˆé¡¯ç¤º
                const ai = await processFrame(img, false);
                if (ai) {
                    const final = new Image();
                    final.onload = () => { setImage(final); setIsProcessing(false); };
                    final.src = ai.toDataURL();
                } else setIsProcessing(false);
            };
            img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
    };

    const processFrame = async (source, isVideo) => {
        if (!window.bodyPixModel) return null;
        if (autoAlign && window.faceModel) {
            const pred = await window.faceModel.estimateFaces(source, false);
            if (pred.length) {
                const f = pred[0]; const fW = f.bottomRight[0] - f.topLeft[0];
                const scale = (350 * 0.38) / fW;
                setP({ x: ( (isVideo?source.videoWidth:source.width)/2 - (f.topLeft[0] + fW/2)) * scale, y: ((isVideo?source.videoHeight:source.height)*0.42 - (f.topLeft[1] + (f.bottomRight[1]-f.topLeft[1])/2)) * scale, s: Math.min(Math.max(scale, 0.4), 1.2) });
            }
        }
        const seg = await window.bodyPixModel.segmentPerson(source, { internalResolution: 'medium', segmentationThreshold: 0.7 });
        const tc = document.createElement('canvas'); tc.width = isVideo ? source.videoWidth : source.width; tc.height = isVideo ? source.videoHeight : source.height;
        const ctx = tc.getContext('2d');
        if (isVideo) { ctx.save(); ctx.translate(tc.width, 0); ctx.scale(-1, 1); ctx.drawImage(source, 0, 0); ctx.restore(); }
        else ctx.drawImage(source, 0, 0);
        const imgData = ctx.getImageData(0, 0, tc.width, tc.height);
        for (let i = 0; i < imgData.data.length; i += 4) {
            const px = i / 4; const x = px % tc.width; const y = Math.floor(px / tc.width);
            const mX = isVideo ? (tc.width - 1 - x) : x;
            if (!seg.data[y * tc.width + mX]) imgData.data[i + 3] = 0;
        }
        ctx.putImageData(imgData, 0, 0);
        return tc;
    };

    const download = () => {
        const pc = document.createElement('canvas'); const ctx = pc.getContext('2d');
        pc.width = 1800; pc.height = 1200; ctx.fillStyle = "white"; ctx.fillRect(0, 0, 1800, 1200);
        const drawGrid = (cols, rows, w, h, sX, sY, gX, gY) => {
            for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) ctx.drawImage(canvasRef.current, 0, 0, 350, 450, sX + c * (w + gX), sY + r * (h + gY), w, h);
        };
        if (mode === 'MIXED') { drawGrid(4,1,413,531,80,80,15,0); drawGrid(5,1,331,449,80,650,10,0); }
        else if (mode === 'TWO') drawGrid(4,2,413,531,80,80,20,30);
        else drawGrid(5,2,331,449,80,100,15,30);
        const a = document.createElement('a'); a.download = `EzID_Result.png`; a.href = pc.toDataURL(); a.click();
    };

    return (
        <div className="max-w-6xl mx-auto flex flex-col lg:flex-row gap-8 pb-20">
            <div className="w-full lg:w-[450px] flex flex-col items-center">
                <div 
                    className="relative w-full aspect-[35/45] bg-white rounded-[40px] overflow-hidden shadow-2xl border-[12px] border-white select-none"
                    onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}
                    onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={()=>isDragging.current=false}
                >
                    {isCam && <video ref={videoRef} autoPlay playsInline className="absolute inset-0 w-full h-full object-cover opacity-0" />}
                    <canvas ref={canvasRef} width={350} height={450} className="w-full h-full" />
                    
                    <div className="absolute top-5 right-5 flex flex-col gap-4 bg-white/40 p-2 rounded-full backdrop-blur-md">
                        {['white','#007bff','#ff0000'].map(c => (
                            <div key={c} onClick={()=>setBgColor(c)} className={`bg-dot ${bgColor===c?'active':''}`} style={{backgroundColor:c}}></div>
                        ))}
                    </div>
                    {isProcessing && (
                        <div className="absolute inset-0 bg-slate-900/60 backdrop-blur-sm flex flex-col items-center justify-center text-white">
                            <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-white mb-4"></div>
                            <span className="font-black text-sm tracking-widest uppercase">Processing</span>
                        </div>
                    )}
                </div>

                <div className="w-full mt-6 grid grid-cols-2 gap-4 px-2">
                    {isCam ? (
                        <button onClick={() => {
                            const tc = document.createElement('canvas'); tc.width = 350; tc.height = 450;
                            tc.getContext('2d').drawImage(canvasRef.current, 0, 0);
                            const img = new Image(); img.onload = () => { setImage(img); setIsCam(false); };
                            img.src = tc.toDataURL();
                        }} className="col-span-2 bg-red-500 text-white py-4 rounded-3xl font-black shadow-xl active:scale-95 transition">ğŸ“¸ æ‹æ”å­˜æª”</button>
                    ) : (
                        <>
                            <button onClick={() => { setIsCam(true); navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } }).then(s => videoRef.current.srcObject = s); }} className="bg-slate-900 text-white py-4 rounded-3xl font-black active:scale-95 transition shadow-lg">ğŸ“· ç›¸æ©Ÿ</button>
                            <label className="bg-white border-2 border-slate-900 py-4 rounded-3xl font-black text-center cursor-pointer active:scale-95 transition shadow-lg">ğŸ“ ä¸Šå‚³ <input type="file" className="hidden" onChange={handleFileUpload} accept="image/*" /></label>
                        </>
                    )}
                </div>
            </div>

            <div className="flex-1 space-y-6">
                <section className="bg-blue-50 p-5 rounded-3xl border-l-4 border-blue-500 flex items-start gap-4">
                    <span className="text-2xl">ğŸ“±</span>
                    <p className="text-blue-700 font-bold text-xs leading-relaxed">æ‰‹å‹¢æç¤ºï¼šé¸å–è¡£æœå¾Œï¼Œç›´æ¥åœ¨ç…§ç‰‡ä¸Šã€Œå–®æŒ‡æ‹–æ›³ã€ç§»å‹•ï¼Œã€Œå…©æŒ‡æ”¶åˆã€ç¸®æ”¾è¡£æœå¤§å°ã€‚</p>
                </section>

                <div className="bg-white p-6 md:p-8 rounded-[40px] shadow-sm border border-slate-100 space-y-8">
                    <div className="flex justify-between items-center">
                        <h1 className="text-2xl font-black">EzID <span className="text-blue-600">PRO</span></h1>
                        <label className="flex items-center gap-2 cursor-pointer bg-green-50 px-3 py-1 rounded-full border border-green-100">
                            <span className="text-[10px] font-bold text-green-600">AI å°é½Š</span>
                            <input type="checkbox" checked={autoAlign} onChange={e=>setAutoAlign(e.target.checked)} className="accent-green-500 w-4 h-4" />
                        </label>
                    </div>

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-10">
                        <section className={`space-y-4 ${autoAlign ? 'opacity-30 pointer-events-none' : ''}`}>
                            <h3 className="text-[11px] font-black text-slate-400 uppercase tracking-widest">äººåƒæ‰‹å‹•</h3>
                            <div className="space-y-4">
                                <div className="flex items-center gap-4 text-xs font-bold"><span>å¤§å°</span><input type="range" min="0.3" max="1.5" step="0.01" value={p.s} onChange={e=>setP({...p,s:parseFloat(e.target.value)})} className="flex-1 accent-slate-900"/></div>
                                <div className="flex items-center gap-4 text-xs font-bold"><span>å·¦å³</span><input type="range" min="-150" max="150" value={p.x} onChange={e=>setP({...p,x:parseInt(e.target.value)})} className="flex-1 accent-slate-900"/></div>
                                <div className="flex items-center gap-4 text-xs font-bold"><span>ä¸Šä¸‹</span><input type="range" min="-150" max="150" value={p.y} onChange={e=>setP({...p,y:parseInt(e.target.value)})} className="flex-1 accent-slate-900"/></div>
                            </div>
                        </section>

                        <section className="space-y-4">
                            <h3 className="text-[11px] font-black text-blue-500 uppercase tracking-widest">è¥¿è£é¸æ“‡</h3>
                            <div className="space-y-4">
                                <div className="flex gap-3 overflow-x-auto pb-2 no-scrollbar">
                                    {['m1','m2','m3','m4','m5'].map(n=>(
                                        <div key={n} onClick={()=>setSuit({...suit,id:n})} className={`p-1 rounded-2xl border-2 shrink-0 cursor-pointer transition-all ${suit.id===n?'border-blue-600 bg-blue-50 scale-105 shadow-md':'border-slate-100 opacity-40'}`}>
                                            <img src={getClothesPath(n)} className="w-16 h-16 object-contain" />
                                        </div>
                                    ))}
                                    <button onClick={()=>setSuit({...suit,id:null})} className="px-5 border-2 border-dashed rounded-2xl text-slate-300 font-bold text-[10px] shrink-0">æ¸…é™¤</button>
                                </div>
                                <div className="flex items-center gap-4 text-xs font-bold text-blue-600 md:flex">
                                    <span className="shrink-0">æ‰‹å‹•å¤§å°</span>
                                    <input type="range" min="0.1" max="0.8" step="0.01" value={suit.s} onChange={e=>setSuit({...suit,s:parseFloat(e.target.value)})} className="flex-1 accent-blue-600"/>
                                </div>
                            </div>
                        </section>
                    </div>
                    
                    <div className="pt-6 border-t border-slate-50 flex flex-col md:flex-row gap-6 items-center">
                        <div className="flex-1 w-full flex gap-2 p-1 bg-slate-100 rounded-2xl">
                            {[['MIXED','æ··åˆ'],['TWO','2å‹'],['ONE','1å‹']].map(([k,v])=>(
                                <button key={k} onClick={()=>setMode(k)} className={`flex-1 py-3 rounded-xl font-black text-xs transition ${mode===k?'bg-white text-slate-900 shadow-sm':'text-slate-500'}`}>{v}</button>
                            ))}
                        </div>
                        <button onClick={download} className="w-full md:w-auto px-12 bg-slate-900 text-white py-6 rounded-[32px] font-black text-lg shadow-2xl active:scale-95 transition">ğŸ’¾ ä¸‹è¼‰æ’ç‰ˆ</button>
                    </div>
                </div>
            </div>
        </div>
    );
};

ReactDOM.createRoot(document.getElementById('root')).render(<EzIDApp />);
</script>
</body>
</html>
